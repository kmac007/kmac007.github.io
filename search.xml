<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MongoDB与Mongoose学习总结]]></title>
    <url>%2F2017%2FMongoDB%E4%B8%8EMongoose%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[为了能够使用Node.js实现前后端分离，MongoDB是必学的，Mongodb是基于文档的非关系型数据库，文档是按BSON（JSON的轻量化二进制格式）存储的，增删改查等管理数据库的命令和JavaScript语法很像。以下是我的学习笔记。 NoSQL简介 NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。 优点: 高可扩展性 分布式计算 低成本 架构的灵活性，半结构化数据 没有复杂的关系 缺点: 没有标准化 有限的查询功能（到目前为止） 最终一致是不直观的程序 MongoDB 简介 MongoDB是NoSQL数据库的一种MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 主要特点 MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 MongoDB安装简单。 启动方法 设置dbpath参数值为自定义的目录路径，如: 1mongod --dbpath=C:/data/db 在test文件夹中新建一个mongod.conf文件，在这个文件中设置mongodb启动的配置参数 123//mongod.confdbpath = datalogpath = log/mongod.log 启动1mongod -f conf/mongod.conf 执行后命令行工具中没有任何提示，记录保存到日志文件中，mongodb服务已正常开启 windows用户可以直接执行mongod.exe可执行文件来直接启动服务器 连接服务器启动好服务器时，保证命令行工具不关闭，重新开一个命令行工具，通过以下方式连接数据库1mongo 127.0.0.1/test 其中test为数据库名称 关闭服务器切换到admin数据库，执行db.shutdownServer()命令来关闭，如:12use admindb.shutdownServer() 数据库操作MongoDB中默认的数据库为test，如果没有创建新的数据库，集合将存放在test数据中 查看数据库使用show dbs来查看数据库1show dbs 创建/切换使用use命令来切换/创建数据库，use db_name，当使用show dbs时，会发现新创建的数据库不在列表中，要使其显示，则需要向数据库插入一些数据。1use db_name 显示当前数据库使用db命令来显示当前数据库1db 将数据库写入集合中使用db.集合名.insert(文档)来将文档的数据写入集合中，文档的格式为JSON。而所有存储在集合中的数据都是BSON格式。BSON是一种类JSON 的二进制形式的存储格式。简称Binary JSON。1db.collection_name.insert(&#123;'name': 'dk'&#125;) 查看集合使用show collections命令可以查看当前数据库中的所有集合1show collections 删除数据库1db.dropDatabase() 将删除当前所选的数据库 集合操作集合类似于SQL数据库中的数据表，标识为collection 查看集合可以使用命令show collections检查所创建的集合注: 也可以使用show tables来查看集合123show collections//orshow tables 创建集合通过db.createCollection(‘collection_name’)1db.createCollection(name, &#123;capped: &lt;Boolean&gt;, autoIndexId: &lt;Boolean&gt;, size: &lt;number&gt;, max &lt;number&gt;&#125; ) name:集合的名字 capped:是否启用集合限制，如果开启需要制定一个限制条件，默认为不启用，这个参数没有实际意义 max:集合中最大条数限制，默认为没有限制 size:限制集合使用空间的大小，默认为没有限制，size的优先级比max要高 autoIndexId:是否使用_id作为索引，默认为使用(true或false) 注意： 向集合中插入文档时，若集合不存在，则会自动创建集合 删除集合通过db.collection_name.drop()用于数据库中删除集合。如果选定的集合成功删除，drop()方法将返回true，否则返回false1db.test.drop() 数据类型1234567891011121314151617181920类型 数字 备注Double 1 双精度浮点数 - 此类型用于存储浮点值String 2 字符串 - 这是用于存储数据的最常用的数据类型。MongoDB中的字符串必须为UTF-8Object 3 对象 - 此数据类型用于嵌入式文档Array 4 数组 - 此类型用于将数组或列表或多个值存储到一个键中Binary data 5 二进制数据 - 此数据类型用于存储二进制数据Undefined 6 已废弃Object id 7 对象ID - 此数据类型用于存储文档的IDBoolean 8 布尔类型 - 此类型用于存储布尔值(true / false)值Date 9 日期 - 此数据类型用于以UNIX时间格式存储当前日期或时间。可以通过创建日期对象并将日，月，年的日期进行指定自己需要的日期时间Null 10 Null - 此类型用于存储Null值Regular 11 正则表达式 - 此数据类型用于存储正则表达式JavaScript 13 代码 - 此数据类型用于将JavaScript代码存储到文档中Symbol 14 符号 - 该数据类型与字符串相同；但是，通常保留用于使用特定符号类型的语言JavaScript (with scope) 15 代码 - 此数据类型用于将带作用域的JavaScript代码存储到文档中32-bit integer 16 32位整型 - 此类型用于存储数值Timestamp 17 时间戳 - 当文档被修改或添加时，可以方便地进行录制64-bit integer 18 64位整型 - 此类型用于存储数值Min key 255 最小键 - 此类型用于将值与最小BSON元素进行比较Max key 127 最大键 - 此类型用于将值与最大BSON元素进行比较 $type$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果1234567&gt; db.p.find()&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125;&#123; "_id" : ObjectId("59ae07bc6d43ce69e75b278b"), "x" : 2 &#125;&#123; "_id" : ObjectId("59ae07c26d43ce69e75b278c"), "x" : true &#125;&#123; "_id" : ObjectId("59ae07ca6d43ce69e75b278d"), "x" : false &#125;&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e"), "x" : "abc" &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f"), "x" : "a" &#125; 查找值类型为数字的x，数字的$type为1123&gt; db.p.find(&#123;"x":&#123;$type:1&#125;&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125;&#123; "_id" : ObjectId("59ae07bc6d43ce69e75b278b"), "x" : 2 &#125; 查找值类型为字符串的x，字符串的$type为2123&gt; db.p.find(&#123;"x":&#123;$type:2&#125;&#125;)&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e"), "x" : "abc" &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f"), "x" : "a" &#125; 查找值类型为布尔值的x，布尔值的$type为8123&gt; db.p.find(&#123;"x":&#123;$type:8&#125;&#125;)&#123; "_id" : ObjectId("59ae07c26d43ce69e75b278c"), "x" : true &#125;&#123; "_id" : ObjectId("59ae07ca6d43ce69e75b278d"), "x" : false &#125; 文档操作这部分将介绍MongoDB数据库文档的增删改查 插入文档要将数据插入到MongoDB集合中，需要使用MongoDB的insert()或save()方法，还有insertOne()和insertMany()方法 insert()1db.COLLECTION_NAME.insert(document) 插入文档时若不指定_id参数，那么MongoDB会为此文档分配一个唯一的ObjectId。_id为集合中每个文档唯一的12个字节的十六进制数。 _id，又称为ObjectId是一个12字节的BSON类型字符串。按照字节顺序依次代表： 4字节：UNIX时间戳 3字节：表示运行MongoDB的机器 2字节：表示生成此_id的进程 3字节：由一个随机数开始的计数器生成的值 如果数据库中不存在集合，则MongoDB将创建此集合，然后将文档插入到该集合中 可以使用js语法，插入多个文档1&gt; for(var i = 0; i &lt; 3; i++)db.p.insert(&#123;y: i&#125;) save()插入文档也可以使用db.p.save(document)。如果不再文档中指定_id，那么save()方法将同insert()方法一样，会自动分配id。 save()方法可以复写和修改，而insert()方法不可以 insertOne()单个文档插入 insertMany()多个文档插入，参数为数组 查询文档find()从MongoDB集合查询数据，使用find()方法，默认返回前20条文档，输入”it”显示接下来的20条文档。find()命令基本语法如下:1db.COLLECTION_NAME.find(document) 限定查询条件:1db.p.find(&#123;x:1&#125;) 可以通过find的第二个参数来指定返回的值，值为1或者true表示显示该键，值为0或false表示不显示该键。如：123456789101112131415161718192021&gt; db.p.find(null, &#123;x:1&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125;&#123; "_id" : ObjectId("59ae07bc6d43ce69e75b278b"), "x" : 2 &#125;&#123; "_id" : ObjectId("59ae07c26d43ce69e75b278c"), "x" : true &#125;&#123; "_id" : ObjectId("59ae07ca6d43ce69e75b278d"), "x" : false &#125;&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e"), "x" : "abc" &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f"), "x" : "a" &#125;&gt; db.p.find(null, &#123;x:0&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a") &#125;&#123; "_id" : ObjectId("59ae07bc6d43ce69e75b278b") &#125;&#123; "_id" : ObjectId("59ae07c26d43ce69e75b278c") &#125;&#123; "_id" : ObjectId("59ae07ca6d43ce69e75b278d") &#125;&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e") &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f") &#125;&gt; db.p.find(null, &#123;_id:0&#125;)&#123; "x" : 1 &#125;&#123; "x" : 2 &#125;&#123; "x" : true &#125;&#123; "x" : false &#125;&#123; "x" : "abc" &#125;&#123; "x" : "a" &#125; 可以通过count()方法显示符合条件的文档数量:12&gt; db.p.find(&#123;x:1&#125;).count()1 findOne()findOne()只返回最早添加的那个文档 比较操作符123456小于 &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;小于或等于 &#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;大于 &#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;大于或等于 &#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;不等于 &#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;等于 &#123;&lt;key&gt;:&#123;$eq:&lt;value&gt;&#125;&#125; 取x小于3的值1db.p.find(&#123;x: &#123;$lt: 3&#125;&#125;) 以此类推 逻辑操作符$and、$or 代表与或12db.p.find(&#123;$and:[&#123;x:1&#125;,&#123;y:2&#125;]&#125;)db.p.find(&#123;$or:[&#123;x:1&#125;,&#123;y:2&#125;]&#125;) 正则表达式文档查询可以使用正则表达式，但只支持字符串类型的数据1234&gt; db.p.find(&#123;x:/a/&#125;)&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e"), "x" : "abc" &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f"), "x" : "a" &#125;&gt; db.p.find(&#123;x:/1/&#125;) $where可以使用任意的JavaScript作为查询条件使用字符串1234&gt; db.p.find(&#123;$where: "this.x===1"&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125;&gt; db.p.find(&#123;$where: "obj.x===1"&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125; 使用函数12&gt; db.p.find(&#123;$where: function()&#123;return this.x === 1&#125;&#125;)&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 1 &#125; limit()如果需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的limit()方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。默认返回前20条文档，输入”it”显示接下来的20条文档1db.p.find().limit(NUMBER) skit()跳过指定数量的数据1db.p.skip(NUMBER) 排序 sort()1db.p.find().sort(&#123;KEY: 1&#125;) 其中1为升序排序，而-1是用于降序排列 更新文档使用updata()或save()方法来更新集合中的文档 update()update()方法用于更新已存在的文档。语法格式如下:1db.collection.update(&lt;query&gt;,&lt;update&gt;,&#123;upsert:&lt;boolean&gt;, multi: &lt;boolean&gt;,writeConcern:&lt;document&gt;&#125;) query : update的查询条件，类似sql update查询内where后面的 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql - update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入- objNew,true为插入，默认是false，不插入 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新 writeConcern :可选，抛出异常的级别 默认只更新找到第一条记录： 将x:1 改为x:10123456789&gt; db.p.update(&#123;x:1&#125;,&#123;$set:&#123;x:10&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.p.find()&#123; "_id" : ObjectId("59ae07b96d43ce69e75b278a"), "x" : 10 &#125;&#123; "_id" : ObjectId("59ae07bc6d43ce69e75b278b"), "x" : 2 &#125;&#123; "_id" : ObjectId("59ae07c26d43ce69e75b278c"), "x" : true &#125;&#123; "_id" : ObjectId("59ae07ca6d43ce69e75b278d"), "x" : false &#125;&#123; "_id" : ObjectId("59ae07d66d43ce69e75b278e"), "x" : "abc" &#125;&#123; "_id" : ObjectId("59ae07da6d43ce69e75b278f"), "x" : "a" &#125; 如果不使用$set，则将文档的内容替换为x:10 更新全部记录，将x:10，更新为x:11db.p.update(&#123;x:10&#125;,&#123;$set:&#123;x:1&#125;,false,true&#125;) save()save()方法可以插入或更新文档，如果参数中的文档_id与集合中所存在的_id不同，则插入，如果相同，则更新 删除文档使用remove()方法来移除集合中的数据 remove()默认地，mongodb删除符合条件的所有文档1db.collection.remove(&lt;query&gt;,&#123;justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt;&#125;) query :删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档。 writeConcern :（可选）抛出异常的级别 1234//删除符合条件的第一个文档db.p.remove(&#123;x:1&#125;,1)//删除符合的所有文档db.p.remove(&#123;x:1&#125;) Mongoose基础什么是MongooseMongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。下面将介绍如何使用Mongoose来操作MongoDB Node.js驱动在介绍Mongoose之前，首先介绍使用Node.js操作MongoDB的方法。如果使用程序操作数据库，就要使用MongoDB驱动。MongoDB驱动实际上就是为应用程序提供一个接口，不同语言对应不同的驱动，Node.js驱动不能应用在其他后端语言中。 安装驱动1npm install mongodb 然后使用require()方法引入mongodb数据库，通过MongoClient对象的connect()方法连接mongodb，最后通过node来对mongodb进行异步的增删改差操作。 在MongoDB数据库中建立db1数据库，然后通过如下代码，即可在集合’col’ 中插入{‘a’:1}文档,如下123456789101112var mongodb = require('mongodb')mongodb.MongoClient.connect("mongdb://localhost/db1", &#123;useMongoClient: true&#125;, function() &#123; if (!err) &#123; db.collection("col").insert(&#123; "a": 1 &#125;, function(err, result) &#123; if (!err) &#123; console.log(result) &#125; &#125;) &#125;&#125;) 输出结果如下：123456&#123; result: &#123; ok: 1, n: 1 &#125;, ops: [ &#123; a: 1, _id: 59ae5283ff6e2d21503d0bc3 &#125; ], insertedCount: 1, insertedIds: [ 59ae5283ff6e2d21503d0bc3 ]&#125; 概述Mongoose是基于Node.js的MongoDB对象模型工具，有以下两个特点： 通过关系型数据库思想来设计非关系型数据库 基于mongodb驱动，简化操作 Mongoose中，有三个比较重要的概念，分别是Schema、Model、Entity。他们关系是： Schema生成Model，Model创造Document，Model和Document都可对数据库操作造成影响，但Model比Document更具操作性。 Schema用于定义数据库的结构。类似创建表时的数据定义（不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等），每个Schema会映射到mongodb中的一个collection，Schema不具备操作数据库的能力。 Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删改差。Model的每个实例(instance)就是一个文档document。 Document是由Model创建的实体，它的操作也会影响数据库。 安装安装nodejs和mongodb之后，使用npm安装mongoose1npm install mongoose 安装成功后通过require(‘mongoose’)来使用 连接数据库通过require引入mongoose后，通过connect()方法即可连接到数据库 connect()1mongoose.connect(url) 如果还需要传递用户名、密码，则可以使用如下方式：1mongoose.connect('mongodb://username:password@host:port/database?options...') connect()方法还接受一个选项对象options，该对象将传递给底层驱动程序。这里所包含的所有选项优先于连接字符创中传递的选项1mongoose.connect(uri，options) options可用选项如下：12345678db -数据库设置server -服务器设置replset -副本集设置user -用户名pass -密码auth -鉴权选项mongos -连接多个数据库promiseLibrary 如:123456789var options = &#123; db: &#123; native_parser: true &#125;, server: &#123; poolSize: 5 &#125;, replset: &#123; rs_name: 'myReplicaSetName' &#125;, user: 'myUserName', pass: 'myPassword'&#125;mongoose.connect(uri, options) 如果要连接多个数据库，只需要设置多个url以逗号隔开，同时设置mongos为true123mongoose.connect('urlA, urlB',&#123; mongos: true&#125;) connect()方法还接受一个回调函数作为参数123mongoose.connect(uri, options, function(error)&#123;&#125;) disconnect()通过mongoose.disconnect() 方法可以断开连接 SchemaSchema主要用于定义MongoDB中集合Collection里文档document的结构定义Schema非常简单,指定字段名和类型即可，支持的类型包括以下8种。12345678String 字符串Number 数字Date 日期Buffer 二进制Boolean 布尔值Mixed 混合类型ObjectId 对象IDArray 数组 通过mongoose.Schema来调用Schema，然后用new方法创建schema对象123456789101112131415var mongoose = require('mongoose')var Schema = mongoose.Schemavar mySchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;) 注意：创建Schema对象时，声明字段类型有两种方法，一种是首字母大写的字段类型，另一种是引号包含的小写字段类型123var mySchema = new Schema(&#123; title: String, author: String &#125;)//orvar mySchema = new Schema(&#123;title: 'string', author: 'string'&#125;) 如需在Schema定义后添加其他字段，可以使用add()方法12var mySchema = new SchemamySchema.add(&#123; name: String, color: String &#125;) Model模型Model是根据Schema编译出的构造器，或者称之为类，通过Model可以实例化出文档对象document文档document的创建和检索都需要通过模型Model来处理 model1mongoose.model() 使用model()方法，将Schema编译为Model。model()方法的第一个参数是模型名称 注意：一定要将model()方法的第一个参数和其要赋值的变量设置为相同的值，否则会出现不可预知的结果 Mongoose会将集合名称设置为模版名称的小写版。如果名称的最后一个字符是字母，则会变成复数；如果名称的最后一个字符是数字，则不变；如果名称的最后一个字符为数字，则不变。例如： 如果Model名称为MyModel,则集合名称为mymodels；如果Model名称为Model1，则集合名称为model112var schema = new mongoose.Schema(&#123; num: Number, name: String, size: String &#125;)var MyModel = mongoose.model('MyModel', schema) 实例化文档document通过new方法，实例化Model1，获得实例化后的document对象123456789101112var mongoose = require('mongoose')mongoose.connect('mongodb://user:123456@localhost/db1', &#123;useMongoClient: true&#125;, (err)=&gt;&#123; if(err)&#123; console.log('连接失败') &#125;else&#123; console.log('连接成功') var schema = new mongoose.Schema(&#123; num: Number, name: String, size: String &#125;) var MyModel = mongoose.model('MyModel', schema) var doc1 = new MyModel(&#123; size: 'small' &#125;) console.log(doc1.size) //'small' &#125;&#125;) 文档保存通过new Model1()创建的文档doc1，必须通过save()方法，才能将创建的文档保存到数据库的集合中，集合名称为模型名称的小写复数 回调函数是可选的，第一个参数为err，第二个参数为保存的文档对象123doc1.save((err, doc)=&gt;&#123; console.log(doc)&#125;) 1234567891011var mongoose = require(&apos;mongoose&apos;)mongoose.connect(&quot;mongodb://user:123456@localhost/db1&quot;,&#123;useMongoClient: true&#125;, (err)=&gt;&#123; if(!err)&#123; var schema = new mongoose.Schema(&#123; num:Number, name: String, size: String &#125;) var MyModel = mongoose.model(&apos;MyModel&apos;, schema) var doc1 = new MyModel(&#123;size: &apos;small&apos;&#125;) doc1.save((err, doc)=&gt;&#123; console.log(doc) &#125;) &#125;&#125;) 文档新增文档新增有三种方法，一种是save()方法，另一种是使用模型model的create()方法，最后一种是模型的model的insertMany()方法 save()新增{age: 10, name: ‘save’}文档并保存12345678910var mongoose = require('mongoose')mongoose.connect("mongodb://user:123456@localhost/db1", &#123;useMongoClient: true&#125;, (err)=&gt;&#123; if(!err)&#123; var schema = new mongoose.Schema(&#123;age: Number, name: String&#125;) var temp = mongoose.model('temp', schema) new temp(&#123;age: 10, name: save&#125;).save((err, doc)=&gt;&#123; console.log(doc) &#125;) &#125;&#125;) creat()使用save()方法，需要将文档实例化，再使用save方法来保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档1Model.create(doc(s), callback) 新增{name: ‘dk’}，{name: ‘kmac007’}这两个文档1234567891011var mongoose = require(&apos;mongoose&apos;)mongoose.connect(&quot;mongodb://user:123456@localhost/db1&quot;, &#123;useMongoClient: true&#125;, (err)=&gt;&#123; if(!err)&#123; var schema = new mongoose.Schema(&#123;age:Number, name:String&#125;) var temp = mongoose.model(&apos;temp&apos;, schema) temp.create(&#123;name: &apos;dk&apos;&#125;,&#123;name: &apos;kmac007&apos;&#125;,(err, doc1, doc2)=&gt;&#123; console.log(doc1) console.log(doc2) &#125;) &#125;&#125;) insertMany()1Model.insertMany(doc(s), [options], [callback]) 新增{name: ‘dk’}，{name: ‘kmac007’}这两个文档1234567891011var mongoose = require('mongoose')mongoose.connect("mongodb://user:123456@localhost/db1", &#123;useMongoClient: true&#125;, (err)=&gt;&#123; if(!err)&#123; var schema = new mongoose.Schema(&#123;age:Number, name:String&#125;) var temp = mongoose.model('temp', schema) temp.insertMany([&#123;name: 'dk'&#125;,&#123;name: 'kmac007'&#125;],(err, doc1, doc2)=&gt;&#123; console.log(doc1) console.log(doc2) &#125;) &#125;&#125;) 文档查询使用mongoose查询有以下三种方法 find() findById() findOne() find()第一个参数表示查询条件，第二个参数用于控制返回的字段，第三个参数用于配置查询参数，第四个参数是回调函数，形如function(err, docs){}1Model.find(conditions, [projection], [options], [callback]) 数据库demo下有如下数据123456789101112//数据库demo&gt; db.users.find()&#123; "_id" : ObjectId("59ae9882f91085939b189a63"), "name" : "dk", "age" : 18 &#125;&#123; "_id" : ObjectId("59ae988cf91085939b189a64"), "name" : "kmac008", "age" : 28 &#125;&#123; "_id" : ObjectId("59ae9892f91085939b189a65"), "name" : "robb", "age" : 20 &#125;&#123; "_id" : ObjectId("59ae989bf91085939b189a66"), "name" : "robin", "age" : 38 &#125;&#123; "_id" : ObjectId("59ae98a5f91085939b189a67"), "name" : "dark", "age" : 45 &#125; 现在用find()方法找出所有数据12345678910var mongoose = require(&apos;mongoose&apos;);mongoose.connect(&apos;mongodb://localhost/demo&apos;, &#123;useMongoClient: true&#125;,(err)=&gt; &#123; if (!err) &#123; var schema = new mongoose.Schema(&#123; age: Number, name: String &#125;); var users = mongoose.model(&apos;users&apos;, schema); users.find(function(err, docs) &#123; console.log(docs); &#125;); &#125;&#125;); 注意，Mongoose4.11.0以上的版本中，连接数据库的逻辑变动，需要在connect参数options中加上{useMongoClient: true}option 找出年龄大于20的数据123users.find(&#123;age: $gt:20&#125;, (err, docs)=&gt;&#123; console.log(docs)&#125;) 找出年龄大于20且名字里存在’dk’的数据:123users.find(&#123;name: /dk/, age: &#123;$gt:20&#125;, (err, docs)=&gt;&#123; console.log(docs)&#125;) 找出名字里带有’d’的数据，且只输出’name’字段123users.find(&#123;name: /d/&#125;, name, (err, docs)=&gt;&#123; console.log(docs)&#125;) findById()1Model.findById(id, [projection], [options], [callback]) 显示第0个元素的所有字段123456789var idArr = []users.find((err, docs)=&gt;&#123; docs.forEach((item, index, arr)=&gt;&#123; idArr.push(item._id) &#125;) users.findById(idArr[0],(err, doc)=&gt;&#123; console.log(doc) &#125;)&#125;) findOne()返回查找到所有实例的第一个 常用的查询条件12345678910111213141516171819202122$or 或关系$nor 或关系取反$gt 大于$gte 大于等于$lt 小于$lte 小于等于$ne 不等于$in 在多个值范围内$nin 不在多个值范围内$all 匹配数组中多个值$regex 正则，用于模糊查询$size 匹配数组大小$maxDistance 范围查询，距离（基于LBS）$mod 取模运算$near 邻域查询，查询附近的位置（基于LBS）$exists 字段是否存在$elemMatch 匹配内数组内的元素$within 范围查询（基于LBS）$box 范围查询，矩形范围（基于LBS）$center 范围醒询，圆形范围（基于LBS）$centerSphere 范围查询，球形范围（基于LBS）$slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素 $where如MongoDB中的使用方法相同，可以使用字符串和函数为条件 文档更新文档更新可以使用以下几种方法1234567update()updateMany()find() + save()updateOne()findOne() + save()findByIdAndUpdate()fingOneAndUpdate() update()第一个参数conditions为查询条件，第二个参数doc为所需要的修改的数据，第三个参数options为控制选项，第四个参数是回调函数1Model.update(conditions, doc, [options], [callback]) options有如下选项:1234567safe (boolean)： 默认为true。安全模式。upsert (boolean)： 默认为false。如果不存在则创建新记录。multi (boolean)： 默认为false。是否更新多个查询记录。runValidators： 如果值为true，执行Validation验证。setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。strict (boolean)： 以strict模式进行更新。overwrite (boolean)： 默认为false。禁用update-only模式，允许覆盖记录。 数据库demo下有如下数据123456789101112//数据库demo&gt; db.users.find()&#123; "_id" : ObjectId("59ae9882f91085939b189a63"), "name" : "dk", "age" : 18 &#125;&#123; "_id" : ObjectId("59ae988cf91085939b189a64"), "name" : "kmac008", "age" : 28 &#125;&#123; "_id" : ObjectId("59ae9892f91085939b189a65"), "name" : "robb", "age" : 20 &#125;&#123; "_id" : ObjectId("59ae989bf91085939b189a66"), "name" : "robin", "age" : 38 &#125;&#123; "_id" : ObjectId("59ae98a5f91085939b189a67"), "name" : "dark", "age" : 45 &#125; 现在用update()方法查询age大于20的数据，将其年龄更改为100123456789101112var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/demo', &#123; useMongoClient: true &#125;, function( err) &#123; if (!err) &#123; var schema = new mongoose.Schema(&#123; age: Number, name: String &#125;); var users = mongoose.model('users', schema); users.update(&#123; age: &#123; $gt: 20 &#125; &#125;, &#123; age: 100 &#125;, (err, doc) =&gt; &#123; console.log(doc); &#125;); &#125;&#125;); 这样只会改变找到的第一个数据 要同时更新多个记录，需要设置options里的multi为true。 如果设置的查找条件，数据库里的数据并不满足，默认什么都不会发生。当设置options里的upsert参数为true，若没有符合查询条件的文档，mongo将会综合第一第二个参数，向集合中插入一个新的文档。 注意：update()方法中的回调函数不能省略，否则数据不会被更新。如果回调函数没有什么有用的信息，可用exec()简化代码 1users.update(&#123;name: /d/&#125;, &#123;upsert: true&#125;).exec() updateMany()updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi: false}也无法只更新第一个文档 find() + save()如果需要更新的操作比较复杂，可以使用find() + save()方法来处理，先找到与条件匹配的文档，再通过forEach遍历，然后通过save()方法更新数据 updateOne()默认更新一个文档，即使设置{multi: true}也无法更新多个 findOne()+save()findOneAndUpdate()findByIdAndUpdate文档删除有三种方法用于文档删除123remove()findOneAndRemove()findByIdAndRemove() remove()remove()有两种形式，一种是文档的remove()方法，一种是Model的remove()方法 Model的remove()方法该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}1model.remove(conditions, [callback]) 注意：remove()方法中的回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码1model.remove(&#123;x:1&#125;).exec() 文档的remove()方法该方法的参数回调函数的形式如下function(err, doc){}12document.remove([callback])//这里的callback可以省略 findOneAndRemove()findByIdAndRemove()参考: mongoose docs Mongoose入门基础]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化规范CommonJS,AMD,CMD浅析]]></title>
    <url>%2F2017%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[为什么使用模块化在多人合作的项目中，如果每个人都定义全局变量，难免会出现命名冲突的问题，这是难以维护的。同时分工合作的过程中，如果一人写一个js文件，我的js又需要依赖于另一个js文件，当文件多了，依赖关系变得十分混乱。而模块化编程正好可以解决这些问题。 模块化的目的 解决命名冲突 依赖管理 提高代码的可读性 代码解耦，提高复用性 立即执行函数写一个模块1234567891011121314var module = (function()&#123; var _count = 0 var m1 = function()&#123; //... &#125; var m2 = function()&#123; //... &#125; return &#123; m1: m1, m2: m2 &#125;&#125;)() 这种方法达到了不暴露私有成员的目的 CommonJSCommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.js首先采用了js模块化的概念。 在CommonJS中，有一个全局方法require(),用于加载模块。假如有一个math.js123456789101112//math.jsfunction add(num) &#123; return num++&#125;function reduce(num) &#123; return num--&#125;module.exports = &#123; add: add, reduce: reduce&#125; 引入math.js模块并调用模块的方法 123var math = require('math')console.log(math.add(1)) // 2console.log(math.reduce(1)) //0 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。 CommonJS加载模块是同步的，所以加载完成后才能执行后面的操作。而Node.js用于服务端，加载模块已经存在本地磁盘，不用考虑异步加载方式，所以CommonJS比较适用。而在浏览器中，如果同步加载js会阻塞整个页面，这对用户是相当不友好的。而AMD、CMD规范则是解决这个问题的。 AMDAMD(Asynchronous Module Definition，异步模块定义)指定一种机制，它采用异步方式加载模块，模块的加载不会影响后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行，这对浏览器的异步加载尤其适用。 实现AMD规范的库有require.js和curl.js等。 语法： 定义模块1define(id?, dependencies?, factory) 第一个参数id为字符串类型，表示了模块标识，为可选参数。若不存在标识应该默认定义为在加载器中被请求脚本的标识。如果存在,那么模块标识必须为顶层的或者一个绝对的标识。 第二个参数denpendencies，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 第三个参数factory，是一个需要进行实例化的函数或者一个对象 加载模块AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数: 1require([module], callback) 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。 AMD规范的实现，require.jsrequire.js要解决什么问题最早的时候，所有Javascript代码都写在一个文件里，只要加载一个文件就够了，随着项目的庞大，需要加载多个js文件。1234&lt;script src="a.js"&gt;&lt;/script&gt;&lt;script src="b.js"&gt;&lt;/script&gt;&lt;script src="c.js"&gt;&lt;/script&gt;&lt;script src="d.js"&gt;&lt;/script&gt; 这种写法有很大的缺点，首先，加载JS文件的时候，浏览器会停止渲染，加载文件越多，网页失去响应的时间也越长；另外，由于依赖关系，我们必须按照a,b,c,d的顺序来依次写script标签，这不利于依赖管理，代码的编写和维护会变得难以处理。 require.js就是为了解决这两个问题的： 实现js文件的异步加载，避免网页失去响应 管理模块之间的依赖性，便于代码的编写和维护 require.js加载假定我们自己的代码文件是main.js，放在js目录下 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块，如main.js，由于require.js默认文件后缀名是js，所有可以把main.js简写成main 主模块的写法主模块依赖于其他模块，这时要使用AMD规范定义的require()函数 1234//main.jsrequire(['moduleA', 'moduleB', 'moculeC'], function(moduleA, moduleB, moduleC)&#123; // do something&#125;) require()函数接受两个参数，第一个参数是一个数组，表示依赖的模块，moduleA、moduleB、moduleC，即主模块依赖这三个模块；第二个参数是一个回到函数，表示当前三个模块加载成功后，回调函数将被调用 模块的加载可以通过require.config()方法对模块的加载行为进行自定义。require.config()就写在主模块main.js的头部。参数是一个对象，123456require.config(&#123; baseUrl: "", paths: &#123; //如: "jquery": "jquery.min" &#125;&#125;) AMD 模块的写法require.js加载的模块，采用AMD规范。 模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。如: 12345678910111213//math.jsdefine(function()&#123; var add = function(num)&#123; return num++ &#125; var reduce = function(num)&#123; return num-- &#125; return &#123; add: add, reduce: reduce &#125;&#125;) 加载方法如下： 1234//main.jsrequire(['math'],function(math)&#123; console.log(math.add(num))&#125;) 如果模块依赖于其他模块，那么define()函数的第一个参数必须是数组，指明模块的依赖 12345678910//math.jsdefine(['caculate'],function(caculate)&#123; function foo()&#123; caculate.doSomething() &#125; return &#123; foo: foo &#125;&#125;) 当require()函数加载math.js时，会先加载caculate.js 加载非规范的模块加载非规范的模块要在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 CMDCMD是SeaJS在推广过程中对模块定义的规范,CMD则是依赖就近，用的时候再require。它写起来是这样的：1234567891011//CMDdefine(function(require, exports, module)&#123; var math = require('math') //依赖可以就近书写 math.add()&#125;)//AMD默认推荐define(['a','b'], function(a, b)&#123; //依赖必须一开始就写好 a.doSomething() b.doSomething()&#125;) AMD与CMD两者皆为异步加载模块，区别是对依赖模块的执行时机不同。 AMD依赖前置，JS可以方便的知道依赖是谁，立即加载；而CMD就近依赖，需要使用模块时在require() 参考Javascript模块化编程（一）：模块的写法Javascript模块化编程（二）：AMD规范Javascript模块化编程（三）：require.js的用法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象以及几种继承的实现方式]]></title>
    <url>%2F2017%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[OOPOOP指的是Object oriented programming指的是面向对象的程序设计。其中最重要的概念是类和对象 类：具备某些属性和方法的模型。 对象：把类实例化就是一个个对象。 面向对象编程有以下三个特性： 继承性：子类继承父类的属性和方法，并可以添加新的属性和方法，或者对部分属性和方法进行重写。继承增加了代码的可重用性。 封装性：把类的属性的方法封装起来，暴露接口，使用方便 多态性：子类继承了父类的属性和方法，同时子类的方法可以进行重写。 创建对象的几种方式 对象字面量 12var obj1 = &#123;&#125;var obj2 = new Object() 构造函数 1234var Foo = function()&#123; this.name = 'dk'&#125;var obj = new Foo() Object.create() 12345var P = &#123;name: 'dk'&#125;var obj = Object.create(P)/*** Object.create()传递两个参数,第一个参数指定新创建对象的prototype,第二个属性可选。包含一个或多个属性描述符的 JavaScript 对象。如writable、enumerable和configurable*/ 类的声明构造函数123function Animal()&#123; this.name = "name"&#125; class声明12345class Animal2&#123; constructor()&#123; this.name = "name" &#125;&#125; 实例化12new Animal()new Animal2() 继承的几种实现方式一、借助构造函数实现继承12345678910function Parent() &#123; this.name = "parent"&#125;Parent.prototype.age = 23function Child() &#123; Parent.call(this) this.type = "child1"&#125;var xiaoming = new Child() 缺点：12xiaoming.__proto__.__proto__ === Parent.prototype //falsexiaoming.__proto__.__proto__ === Object.prototype //true 这个方法只继承的Parent构造函数中的属性，Parent.prototype上的属性与方法并不能被Child继承(这种方式会导致实例的原型链并不能指向Parent.prototype) 二、借助原型链实现继承1234567891011function Parent()&#123; this.name = "xiaoming" this.arr = [1,2,3]&#125;function Child()&#123; this.type = "child"&#125;Child.prototype = new Parent()var xiaoming1 = new Child()var xiaoming2 = new Child() 1xiaoming.__proto__.__proto__ === Parent.prototype //true 缺点:父类增加新的属性，那么所有的实例也会同时发生改变。如上所示，由于实例xiaoming1与xiaoming2的__proto__属性指向同一个原型对象，因此，如果改变Parent中的arr，那么xiaoming1和xiaoming2的arr会同时改变，这是我们不想要的。(子类实例没有自己的属性) 三、组合继承12345678910111213function Parent() &#123; this.name = "parent" this.arr = [1, 2, 3]&#125;function Child() &#123; Parent.call(this) this.type = "child"&#125;Child.prototype = new Parent()var obj1 = new Child()var obj2 = new Child() 缺点：父对象执行了两次，这没有必要，并且无法区分实例对象是Child的直接实例还是Parent的实例 四、组合继承优化112345678910111213function Parent() &#123; this.name = "parent" this.arr = [1, 2, 3]&#125;function Child() &#123; Parent.call(this) this.type = "child"&#125;Child.prototype = Parent.prototypevar obj1 = new Child()var obj2 = new Child() 缺点:实例的constructor指向的是Parent，无法区分实例是Parent的实例还是Child的直接实例 五、组合继承优化2123456789101112131415function Parent() &#123; this.name = "parent" this.arr = [1, 2, 3]&#125;function Child() &#123; Parent.call(this) this.type = "child"&#125;Child.prototype = Object.create(Parent.ptototype)Child.prototype.constructor = Childvar obj1 = new Child()var obj2 = new Child() ES6 class继承12345678910111213141516class Parent &#123; constructor()&#123; this.name = "parent" this.arr = [1, 2, 3] &#125;&#125;class Child extends Parent&#123; constructor()&#123; super() this.type="child" &#125;&#125;var obj1 = new Child() 面向对象组件jQuery轮播组件的面向对象写法预览 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Carousel&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li &#123; list-style: none; &#125; #carousel &#123; margin: 15px auto; position: relative; overflow: hidden; width: 790px; height: 340px; &#125; #carousel::after &#123; content: ''; display: block; clear: both; &#125; .img-ct &#123; position: absolute; left: 0; &#125; .img-ct li &#123; float: left; &#125; .img-ct li img &#123; width: 790px; height: 340px; &#125; .playPre &#123; position: absolute; left: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: .6; background-color: #ccc; z-index: 1; &#125; .playNext &#123; position: absolute; right: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: 0.6; background-color: #ccc; z-index: 1; &#125; .playPre:hover, .playNext:hover &#123; opacity: .9; &#125; .bullet &#123; position: absolute; z-index: 1; bottom: 15px; left: 50%; margin-left: -60px; &#125; .bullet&gt;li &#123; width: 10px; height: 10px; border-radius: 100%; background-color: #fff; float: left; margin: 0 10px; cursor: pointer; &#125; .bullet&gt;li.active &#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt; &lt;div class="container2"&gt;&lt;/div&gt; &lt;script&gt; // 传入轮播图的信息 var infoList = [&#123; url: '#', imgSrc: "https://img13.360buyimg.com/da/jfs/t6523/341/824411132/107598/9e0c0471/5944e2a2N1dbd6ab0.jpg" &#125;, &#123; url: '#', imgSrc: "https://img10.360buyimg.com/da/jfs/t5605/218/3703527351/96712/8d910da2/594204e7Necf27dfe.jpg" &#125;, &#123; url: '#', imgSrc: "https://img12.360buyimg.com/da/jfs/t6052/341/2742126351/72451/b5aa6d7/5945252bN141eed38.jpg" &#125;, &#123; url: '#', imgSrc: "https://img12.360buyimg.com/da/jfs/t5779/306/3761419882/121798/e8b4bb9c/59421ed2Ne982edad.jpg" &#125; ] // Carousel可传如两个参数，$ct为容器，infoList为轮播图信息（url与img.src） function Carousel($ct, infoList) &#123; this.ct = $ct this.isAnimate = false this.pageIndex = 0 this.render(infoList) this.init() this.bind() this.autoPlay() &#125; // 渲染dom节点 Carousel.prototype.render = function (infoList) &#123; var arr = ['&lt;div id="carousel"&gt;&lt;ul class="img-ct"&gt;'] $.each(infoList, function (index, info) &#123; arr.push('&lt;li&gt;&lt;a href="' + info.url + '"&gt;&lt;img src="' + info.imgSrc + '"&gt;&lt;/a&gt;&lt;/li&gt;') &#125;) arr.push('&lt;/ul&gt;&lt;div class = "playPre"&gt;&lt;&lt;/div&gt;&lt;div class="playNext"&gt;&gt;&lt;/div&gt;&lt;ul class="bullet"&gt;') $.each(infoList, function (idx, info) &#123; arr.push("&lt;li&gt;&lt;/li&gt;") &#125;) arr.push("&lt;/ul&gt;&lt;/div&gt;") var renderDom = arr.join('') this.ct.append($(renderDom)) this.ct.find(".bullet li").eq(0).addClass("active") &#125; //初始化参数 Carousel.prototype.init = function () &#123; var $imgCt = this.ct.find('.img-ct'), $imgs = this.ct.find('.img-ct li'), imgsCount = $imgs.length, imgWidth = $imgs.eq(0).width() $imgCt.append($imgs.eq(0).clone()) $imgCt.prepend($imgs.last().clone()) $imgCt.width((imgsCount + 2) * imgWidth) $imgCt.css(&#123; left: -imgWidth &#125;) this.imgCt = $imgCt this.imgs = $imgs this.imgsCount = imgsCount this.imgWidth = imgWidth &#125; // 绑定事件 Carousel.prototype.bind = function () &#123; var _this = this this.ct.find(".playNext").on('click', function () &#123; _this.playNext(1) &#125;) this.ct.find(".playPre").on('click', function () &#123; _this.playPre(1) &#125;) this.ct.find(".bullet li").on('click', function () &#123; var index = $(this).index() if (index &gt; _this.pageIndex) &#123; _this.playNext(index - _this.pageIndex) &#125; else if (_this.pageIndex &gt; index) &#123; _this.playPre(_this.pageIndex - index) &#125; &#125;) &#125; // 向后播放 Carousel.prototype.playNext = function (len) &#123; var _this = this if (this.isAnimate) return this.isAnimate = true this.imgCt.animate(&#123; left: "-=" + len * _this.imgWidth &#125;, function () &#123; _this.pageIndex += len if (_this.pageIndex === _this.imgsCount) &#123; _this.pageIndex = 0 _this.imgCt.css(&#123; left: -_this.imgWidth &#125;) &#125; _this.isAnimate = false _this.setBullet() &#125;) &#125; // 向前播放 Carousel.prototype.playPre = function (len) &#123; var _this = this if (this.isAnimate) return this.isAnimate = true this.imgCt.animate(&#123; left: "+=" + len * _this.imgWidth &#125;, function () &#123; _this.pageIndex -= len if (_this.pageIndex &lt; 0) &#123; _this.pageIndex = _this.imgsCount - 1 _this.imgCt.css(&#123; left: -_this.imgsCount * _this.imgWidth &#125;) &#125; _this.isAnimate = false _this.setBullet() &#125;) &#125; // 设置轮播图下部导航标 Carousel.prototype.setBullet = function () &#123; this.ct.find('.bullet li').removeClass('active').eq(this.pageIndex).addClass('active') &#125; Carousel.prototype.autoPlay = function () &#123; var _this = this setInterval(function () &#123; _this.playNext(1) &#125;, 3000) &#125; var carousel1 = new Carousel($(".container"), infoList) var carousel2 = new Carousel($(".container2"), infoList) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQurey图片懒加载的面向对象写法预览 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;lazyLoad&lt;/title&gt; &lt;style&gt; .wrap &#123; margin: 0 auto; width: 800px; &#125; img &#123; width: 350px; height: 200px; background-color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=1"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=2"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=3"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=4"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=5"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=6"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=7"&gt; &lt;img src="http://fakeimg.pl/350x200/?text=8"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=9"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=10"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=11"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=12"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=13"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=14"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=15"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=16"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=17"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=18"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=19"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=20"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=21"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=22"&gt; &lt;img src="" data-src="http://fakeimg.pl/350x200/?text=23"&gt; &lt;/div&gt; &lt;script&gt; var LazyLoad = function (img) &#123; this.target = img this.bind() this.check(this.target) &#125; // 绑定滚动事件 LazyLoad.prototype.bind = function () &#123; var _this = this $(window).on('scroll', function () &#123; if (_this.check(_this.target)) &#123; var dataSrc = _this.target.attr('data-src') _this.target.attr('src', dataSrc) &#125; &#125;) &#125; //判断目标图片是否在可视范围内 LazyLoad.prototype.check = function ($node) &#123; console.log($node) var scrollTop = $(window).scrollTop(), windowHeight = $(window).height(), offsetTop = $node.offset().top, nodeHeight = $node.outerHeight(true) if (scrollTop + windowHeight &gt; offsetTop &amp;&amp; scrollTop &lt; offsetTop + nodeHeight) &#123; return true &#125; return false &#125; // 遍历给每个图片绑定事件 $('.wrap img').each(function () &#123; new LazyLoad($(this)) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链、this与new操作符]]></title>
    <url>%2F2017%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81this%E4%B8%8Enew%E6%93%8D%E4%BD%9C%E7%AC%A6.html</url>
    <content type="text"><![CDATA[prototype首先如下代码所示，声明一个构造函数，并实例化12345function Person(name)&#123;&#125;Person.prototype.name = "kmac007"var person = new Person() 如上作为构造函数Person的实例person1person.name //kmac007 person实例上并没有这个属性，而这个属性从何而来呢?很明显，这个属性来自Person.prototype 每个函数都有一个prototype属性，就是上面看到的prototype,Person.prototype则表示实例的原型 那么person这个实例与Person.prototype的关系又是怎么样的呢，接下来就有了__proto__ __proto__每个JavaScript对象（除了null）都有一个隐式原型属性__proto__,这个属性指向创建该对象构造函数的prototype,而构造函数原型的constructor属性指向构造函数本身如下12345678function Person(name)&#123;&#125;Person.prototype.name = "kmac007"var person = new Person()person.__proto__ === Person.prototype //truePerson.prototype.constructor === Person //true 那么Person.prototype对象的__proto__又是什么呢12Person.prototype.__proto__ === Object.prototype //trueObject.prototype.__proto__ === null //true 由上可知实例对象通过__proto__与原型对象一层一层的连接当我们使用person.toString()方法时，实例对象本身没有，因此通过person.__proto__向它的原型对象查找，如再找不到，则继续往它原型对象的原型对象查找person.__proto__.__proto__，最终在Object.prototype上找到了toString()方法。 而这种由__proto__相互关联的原型组成的链式结构就称作原型链。如下蓝色线条所示。 this全局this浏览器环境下this指向window对象，在任何情况下，创建变量时没有加上var或let相当于创建了一个全局变量。 Node命令行中，this===global true 在命令行中进行求值会赋值在this上123foo = "bar"console.log(this.foo) //barconsole.log(global.foo) //bar 在Node环境中执行JS脚本，有所不同。this其实是个空对象，有别于global 1234//a.jsfoo = "bar"console.log(this.foo) //undefinedconsole.log(global.foo) //bar 函数或方法里的this函数被调用时12345678var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() //objbar() //window 函数的调用过程如下: func.call(context) context即调用时的上下文 因此上面的调用过程如下:obj.foo() 相当于 obj.foo.call(obj) this指向objbar() 相当于 bar.call(undefind) 而在浏览器环境中undefined默认指向window(注意：在严格模式下undefined并不指向window) 个人了解的this的使用场景123456var obj = &#123; a: 1, b: function() &#123; console.log(this); &#125;&#125; 作为对象调用时，obj.b(); // 指向obj 作为函数调用, var b = obj.b; b(); // 指向全局window 作为构造函数调用 var b = new Fun(); // this指向当前实例对象 作为call与apply调用 obj.b.apply(object, []); // this指向当前的object call,apply,bindcall()和apply()的作用是改变函数的执行上下文，改变this的指向，第一部分参数是要指定的执行上下文，第二部分则是传入的参数。二者的区别在于传入参数的形式的不同，如：12func.apply(Obj, [argArray])func.call(Obj, arg1, arg2, arg3) bind()是ES5的方法，它是用来实现上下文的绑定，与call相似，可接受的参数部分分为两部分，第一个参数都是作为执行时函数上下文中的this的对象，但是bind的返回值是函数，call是改变上下文并执行函数。(bind()返回一个新的函数) instanceof1instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性。可以检测某个对象是不是另一个对象的实例。 内部逻辑： 123456 A instanceof B,判断规则是:先沿着A的__proto__链向上查找，同时查找B.prototype，一旦二者相等，则返回true，否则返回false。 new MDN当new Foo(…)执行时： 一个新对象被创建。它继承自Foo.prototype 构造函数Foo被执行。执行的时候，相应的参数会被传入，同时上下文(this)会被指定为这个新实例。new Foo等同于new Foo()，只能用在不传递任何参数的情况。 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。 个人总结当new调用一个构造函数Foo时:1234567//1. 创建一个对象var o = &#123;&#125;//2. 设置原型链o.__proto__ = Foo.prototype//3. 将Foo的this指向实例o并执行Foovar k = Foo.call(o)//4. 判断F的返回值类型：如果是值类型，就丢弃它，返回o；如果是引用类型，返回引用类型的这个对象，替换掉o new的代码实现思路如下123456789var new2 = function(func)&#123; var o = Object.create(func.prototype) var k = func.call(o) if(typeof k === 'object')&#123; return k &#125;else&#123; return o &#125;&#125; 参考JavaScript深入之从原型到原型链「每日一题」什么是 JS 原型链？]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型链</tag>
        <tag>this</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery轮播的两种实现]]></title>
    <url>%2F2017%2FjQuery%E8%BD%AE%E6%92%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[轮播图的原理 方法一：通过一个容器将图片存放在一行上，设置一个窗口，并使其属性overflow: hidden，通过改变图片的水平偏移量达到视觉上的轮播效果。另外通过将最后一位图片拷贝一份放至最前，将第一位拷贝一份放置最后，当在第一位向前播放时，显示的是最后一位图片，并实际立刻跳转到最后一位，欺骗了用户，达到了无限轮播的效果。 方法二：容器中有许多图片，将图片所有初始的属性都设为display:none，通过jquery的fadeIn(),和fadeOut()方法，只显示第一张，改变图片的display属性达到渐变轮播的效果 接口： playNext() 向后跳转 playPre() 向前跳转 play(index) 向某索引index跳转 预览及代码滑动轮播 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;!DOCTYPE html&gt;&lt;html lang="zh-Hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Carousel&lt;/title&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li &#123; list-style: none; &#125; #carousel &#123; margin: 15px auto; position: relative; overflow: hidden; width: 790px; height: 340px; &#125; #carousel::after &#123; content: ''; display: block; clear: both; &#125; .img-ct &#123; position: absolute; left: 0; &#125; .img-ct li &#123; float: left; &#125; .img-ct li img &#123; width: 790px; height: 340px; &#125; .playPre &#123; position: absolute; left: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: .6; background-color: #ccc; z-index: 1; &#125; .playNext &#123; position: absolute; right: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: 0.6; background-color: #ccc; z-index: 1; &#125; .playPre:hover, .playNext:hover &#123; opacity: .9; &#125; .bullet &#123; position: absolute; z-index: 1; bottom: 15px; left: 50%; margin-left: -60px; &#125; .bullet&gt;li &#123; width: 10px; height: 10px; border-radius: 100%; background-color: #fff; float: left; margin: 0 10px; cursor: pointer; &#125; .bullet&gt;li.active &#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="carousel"&gt; &lt;ul class="img-ct"&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img13.360buyimg.com/da/jfs/t6523/341/824411132/107598/9e0c0471/5944e2a2N1dbd6ab0.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img10.360buyimg.com/da/jfs/t5605/218/3703527351/96712/8d910da2/594204e7Necf27dfe.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img12.360buyimg.com/da/jfs/t6052/341/2742126351/72451/b5aa6d7/5945252bN141eed38.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img12.360buyimg.com/da/jfs/t5779/306/3761419882/121798/e8b4bb9c/59421ed2Ne982edad.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="playPre"&gt; &lt;&lt;/div&gt; &lt;div class="playNext"&gt;&gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'), $imgs = $('.img-ct li'), imgsCount = $imgs.length, imgWidth = $imgs.eq(0).width(), pageIndex = 0, isAnimate = false $imgCt.append($imgs.eq(0).clone()) $imgCt.prepend($imgs.last().clone()) $imgCt.width((imgsCount + 2) * imgWidth) $imgCt.css(&#123; left: -imgWidth &#125;) $('.playNext').on('click', function () &#123; playNext(1) &#125;) $('.playPre').on('click', function () &#123; playPre(1) &#125;) $('.bullet li').on('click', function () &#123; var index = $(this).index() if (index &gt; pageIndex) &#123; playNext(index - pageIndex) &#125; else if (pageIndex &gt; index) &#123; playPre(pageIndex - index) &#125; &#125;) function playNext(len) &#123; if (isAnimate) return isAnimate = true $imgCt.animate(&#123; left: "-=" + len * imgWidth &#125;, function () &#123; pageIndex += len if (pageIndex === imgsCount) &#123; pageIndex = 0 $imgCt.css(&#123; left: -imgWidth &#125;) &#125; isAnimate = false setBullet() &#125;) &#125; function playPre(len) &#123; if (isAnimate) return isAnimate = true $imgCt.animate(&#123; left: '+=' + len * imgWidth &#125;, function () &#123; pageIndex -= len if (pageIndex &lt; 0) &#123; pageIndex = imgsCount - 1 $imgCt.css(&#123; left: -imgsCount * imgWidth &#125;) &#125; isAnimate = false setBullet() &#125;) &#125; function setBullet() &#123; $('.bullet li').removeClass('active').eq(pageIndex).addClass('active') &#125; setInterval(function () &#123; playNext(1) &#125;, 3000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 渐变轮播 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!DOCTYPE html&gt;&lt;html lang="zh-Hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Carousel&lt;/title&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li &#123; list-style: none; &#125; #carousel &#123; margin: 15px auto; position: relative; overflow: hidden; width: 790px; height: 340px; &#125; #carousel::after &#123; content: ''; display: block; clear: both; &#125; .img-ct &#123; position: absolute; left: 0; &#125; .img-ct li &#123; float: left; display: none; &#125; .img-ct li img &#123; width: 790px; height: 340px; &#125; .playPre &#123; position: absolute; left: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: .6; background-color: #ccc; z-index: 1; &#125; .playNext &#123; position: absolute; right: 0; top: 50%; height: 50px; margin-top: -25px; width: 30px; color: #444; line-height: 50px; text-align: center; font-size: 20px; cursor: pointer; opacity: 0.6; background-color: #ccc; z-index: 1; &#125; .playPre:hover, .playNext:hover &#123; opacity: .9; &#125; .bullet &#123; position: absolute; z-index: 1; bottom: 15px; left: 50%; margin-left: -60px; &#125; .bullet&gt;li &#123; width: 10px; height: 10px; border-radius: 100%; background-color: #fff; float: left; margin: 0 10px; cursor: pointer; &#125; .bullet&gt;li.active &#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="carousel"&gt; &lt;ul class="img-ct"&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img13.360buyimg.com/da/jfs/t6523/341/824411132/107598/9e0c0471/5944e2a2N1dbd6ab0.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img10.360buyimg.com/da/jfs/t5605/218/3703527351/96712/8d910da2/594204e7Necf27dfe.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img12.360buyimg.com/da/jfs/t6052/341/2742126351/72451/b5aa6d7/5945252bN141eed38.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;&lt;img src="https://img12.360buyimg.com/da/jfs/t5779/306/3761419882/121798/e8b4bb9c/59421ed2Ne982edad.jpg"&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="playPre"&gt; &lt;&lt;/div&gt; &lt;div class="playNext"&gt;&gt;&lt;/div&gt; &lt;ul class="bullet"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var $imgCt = $('.img-ct'), $imgs = $('.img-ct li'), imgsCount = $imgs.length, pageIndex = 0, isAnimate = false play(0) $('.playNext').on('click', function () &#123; playNext() &#125;) $('.playPre').on('click', function () &#123; playPre() &#125;) $('.bullet li').on('click', function () &#123; var index = $(this).index() play(index) &#125;) function play(index) &#123; if (isAnimate) return isAnimate = true $imgs.eq(pageIndex).fadeOut(500) $imgs.eq(index).fadeIn(500, function () &#123; isAnimate = false &#125;) pageIndex = index setBullet() &#125; function playNext() &#123; play((pageIndex + 1) % imgsCount) &#125; function playPre(index) &#123; play((imgsCount + pageIndex - 1) % imgsCount) &#125; function setBullet() &#123; $('.bullet li').removeClass('active').eq(pageIndex).addClass('active') &#125; setInterval(function () &#123; playNext() &#125;, 3000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习使用笔记]]></title>
    <url>%2F2017%2FjQuery%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[库vs框架 库: 对原生代码进行一个完整的封装，通过封装解决许多兼容性的问题。用户可以简易的调用API来构建项目，而不需要考虑许多兼容性问题。 框架：会基于自身的特点向用户提供一套完整的模版，用户需要按照框架规范来构建项目。 类比来说：前端库就像我们家里的工具箱，里面有锯子、锤子等工具，需要时，我们从工具箱中取工具；而框架像是房子的骨架，我们通过给房子添加建材等，使其完整。 jQuery的作用jQuery是JavaScript的一个类库，仍是js，jQuery主要用来简化原生js的各种操作以及解决各种浏览器之间的兼容性。jQuery能办到的事情原生js都能办到。通常来说jQuery有以下几个功能： 方便快捷获取DOM元素 动态修改页面样式、动态改变DOM内容 解决跨浏览器兼容 响应用户的交互操作 为页面添加动态效果 统一Ajax操作 简化常见的JavaScript操作 选择器 与原生DOM对象相互转换DOM对象转jQuery对象 1$(document.getElementById("btn") //通过$()将DOM对象包裹起来转换成jQuery对象 jQuery对象转DOM对象 123456&lt;ul class="ct"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 通过类数组下标方式转换成DOM对象 12$(".ct&gt;li")[0]$(".ct&gt;li").eq(0)[0] 通过get方法 1$(".ct&gt;li").get(0) DOM操作创建元素把DOM字符串插入$方法即可返回一个jQuery对象1var obj = $('&lt;div class="test"&gt;&lt;p&gt;&lt;span&gt;kmac007&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;') 添加元素.append([content][,content]) / .before(function)1.append(content[,content]) / .append(function(index, html)) 可以一次添加多个内容，内容可以是DOM对象、HTML string、jQuery对象 如果参数是function，function可以返回DOM对象、HTML string、 jQuery对象，参数是集合中的元素位置与原来的html值 .appendTo(target)把对象插入到目标元素尾部，目标元素可以是selector, DOM对象, HTML string, 元素集合, jQuery对象; .prependTo向对象头部追加内容，用法和append类似，内容添加到最开始 prependTo(target)把对象插入到目标元素头部，用法和prepend类似 .before([content][,content]) / .before(function)在对象前面(不是头部，而是外面，和对象并列同级)插入内容，参数和append类似 .insertBefore(target)把对象插入到target之前（同样不是头部，是同级） .after([content][,content]) / .after(function（index）)和before相反，在对象后面(不是尾部，而是外面，和对象并列同级)插入内容，参数和append类似 .insertAfter(target)和insertBefore相反，把对象插入到target之后（同样不是尾部，是同级） 删除元素.remove([selector])删除被选元素(及其子元素)1$('#div').remove() 也可以添加一个可选的选择器参数来过滤匹配元素1$('div').remove('.test') .empty()清空被选择元素内所有子元素 .detach().detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 包裹元素wrap(wrappingElement) / .wrap(function(index))为每个对象包裹一层HTML结构，可以是selector, element, HTML string, jQuery object1234&lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 包裹元素1$( ".inner" ).wrap( "&lt;div class='new'&gt;&lt;/div&gt;" ); 结果12345678&lt;div class="container"&gt; &lt;div class="new"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class="new"&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; .wrapAll(wrappingElement)把所有匹配对象包裹在同一个HTML结构中1234&lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 包裹元素1$( ".inner" ).wrapAll( "&lt;div class='new' /&gt;"); 结果123456&lt;div class="container"&gt; &lt;div class="new"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; .wrapInner(wrappingElement) / .wrapInner(function(index))1234&lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 包裹元素1$( ".inner" ).wrapInner( "&lt;div class='new'&gt;&lt;/div&gt;"); 结果12345678&lt;div class="container"&gt; &lt;div class="inner"&gt; &lt;div class="new"&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class="inner"&gt; &lt;div class="new"&gt;Goodbye&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; .unwap()把DOM元素的parent移除1pTags = $( "p" ).unwrap(); 读写html([string])这是一个读写两用的方法，用于获取/修改元素的innerHTML 当没有传递参数的时候，返回元素的innerHTML 当传递了一个string参数的时候，修改元素的innerHTML为参数值 如下:123$('div').html()$('div').html('123') text()和html方法类似，操作的是innerHTML 属性&amp;CSS操作属性相关.val([value])处理input的value,无参数时表示获取，有参数时表示修改input的值为参数值 attr(attributeName[,value])传递两个参数，只有attributeName时，获取特定的属性值，有value则修改特定的属性值为value removeAttr()为匹配的元素集合移除相应属性 CSS相关与attr用法相似 css(propertyName) / .css(propertyNames)获取元素style特定property的值 .css(propertyName,value) / .css( propertyName, function(index, value) ) / .css( propertiesJson )设置元素style特定property的值 addClass(className) / .removeClass(className)添加删除class,不覆盖原class,不检查重复 removeClass([className]) / ,removeClass(function(index,class))移除元素单个/多个/所有class .hasClass(className)检查元素是否包含某个class，返回boolean .toggleClass(className)切换class 常用函数.each( function(index, Element) )遍历一个jQuery对象，为每个匹配元素执行一个函数 如123$( "li" ).each(function( index ) &#123; console.log( index + ": "" + $(this).text() );&#125;); jQuery.each( collection, callback(indexInArray, valueOfElement) )一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length - 1。其他对象通过其属性名进行迭代。 1234567var obj = &#123; "flammable": "inflammable", "duh": "no duh"&#125;;$.each( obj, function( key, value ) &#123; alert( key + ": " + value );&#125;); .map( callback(index, domElement) )通过一个函数匹配当前集合中的每个元素,产生一个包含新的jQuery对象 123$('div').map(function(i, ele)&#123; return this.id;&#125;); jQuery.extend([deep,] target [, object1 ] [, objectN ] ) 当我们提供两个或多个对象给$.extend()，对象的所有属性都添加到目标对象（target参数） 如果只有一个参数提供给$.extend()，这意味着目标参数被省略。在这种情况下，jQuery对象本身被默认为目标对象。这样，我们可以在jQuery的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的 目标对象（第一个参数）将被修改，并且将通过$.extend()返回。然而，如果我们想保留原对象，我们可以通过传递一个空对象作为目标对象：1var object = $.extend(&#123;&#125;, object1, object2); 如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写一个属性。这些值不会被合并。如果将 true作为该函数的第一个参数，那么会在对象上进行递归的合并。123456789101112var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;;// Merge object2 into object1$.extend( object1, object2 ); .clone( [withDataAndEvents ] ).clone()方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点 .index() / .index(selector)/ .index(element)从给定集合中查找特定元素index 没参数返回第一个元素index 如果参数是DOM对象或者jQuery对象，则返回参数在集合中的index 如果参数是选择器，返回第一个匹配元素index，没有找到返回-1 .ready( handler )当DOM准备就绪时，指定一个函数来执行,如123$(function()&#123; console.log('ready');&#125;); 事件绑定onon()为事件绑定的首选方法 在被选元素及子元素上添加一个或多个事件处理程序语法: $(selector).on(event,childSelector,data,function,map)参数: event:必需。规定要从被选元素添加的一个或多个事件或命名空间。由空格分隔多个事件值。必须是有效的事件 data:可选。规定只能添加到指定的子元素上的事件处理程序（且不是选择器本身，比如已废弃的 delegate() 方法）。 function:可选。规定当事件发生时运行的函数。 map:规定事件映射 ({event:function, event:function, …})，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。 offoff() 方法通常用于移除通过 on() 方法添加的事件处理程序。 使用on绑定事件使用事件代理的写法：123456789101112//html&lt;ul class="ct"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(".ct").on('click', 'li', function () &#123; console.log($(this).text()) &#125;)&lt;/script&gt; 其他事件: jQuery动画基本展示元素： 1.show( duration [, easing ] [, complete ] ) 隐藏元素： 1.hide([duration ] [,easing ] [,complete ]) 没有参数时直接等同于直接设置选中元素display属性，如： 1234.css('display', 'none').toggle( [duration ] [, easing ] [, complete ] )//用来切换元素的隐藏、显示，类似toggleClass 参数： duration：动画持续的时间。一个字符串或数字决定动画运行的时间。（注：默认值为”400毫秒”） easing：表示过渡使用哪种缓冲函数，jQuery自身提供”linear”和”swing”,默认为”swing” complete：在动画完成时执行的函数渐变.fadeIn.fadeOut.fadeTo.fadeToggle 滑动.slideDown.slideUp.slideToggle 自定义动画1.animate( properties [, duration ] [, easing ] [, complete ] ) properties是一个CSS属性和值的对象,动画将根据这组对象移动。 如： 123456789$('#clickme').click(function() &#123; $('#book').animate(&#123; opacity: 0.25, left: '+=50', height: 'toggle' &#125;, 5000, function() &#123; // Animation complete. &#125;);&#125;); .animate( properties, options ) options是一组包含动画选项的值的集合。 常用的选项: duration (default: 400)：一个字符串或者数字决定动画将运行多久。默认值: “normal”， 三种预定速度的字符串(“slow”, “normal”, 或 “fast”或表示动画时长的毫秒数值(如：1000) ） easing (default: swing)：一个字符串，表示过渡使用哪种缓动函数。jQuery自身提供”linear” 和 “swing”，其他效果可以使用jQuery Easing Plugin插件 step：每个动画元素的每个动画属性将调用的函数。这个函数为修改Tween 对象提供了一个机会来改变设置中得属性值。 complete：在动画完成时执行的函数 Ajax1234567891011121314151617$.ajax(&#123; url: 'xxx.js', method: 'GET', data: &#123; name: 'kmac007', age: 23, sex: 'Male' &#125;&#125;).done(function(result)&#123; console.log(result);&#125;).fail(function(jqXHR, textStatus)&#123; consloe.log(textStatus);&#125;); 参数: async：默认设置下，所有请求均为异步请求（也就是说这是默认设置为 true ）。如果需要发送同步请求，请将此选项设置为 false beforeSend：请求发送前的回调函数，用来修改请求发送前jqXHR对象，此功能用来设置自定义 HTTP 头信息，等等。该jqXHR和设置对象作为参数传递 cache：如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}” context：这个对象用于设置Ajax相关回调函数的上下文。 默认情况下，这个上下文是一个ajax请求使用的参数设置对象 data：发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后面，POST请求作为表单数据 headers：一个额外的{键:值}对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置 ;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 method：HTTP 请求方法 (比如：”POST”, “GET “, “PUT”，1.9之前使用“type”) .serialize() / serializeArray()用于提交表单]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的几种解决方案]]></title>
    <url>%2F2017%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[同源策略浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。所谓的同源策略指的是三个相同： 协议相同 域名相同 端口相同 例如: https://www.kmac007.com/2017/index.html 这个网址，协议是https，域名是kmac007.com，端口是80（默认端口可以省略）对于如下网址： http://www.kmac007.com/2017/index.html 不同源(协议不同) https://www.kmac007.com/2017/first.html 同源 https://kmac007.com/2017/first.html 不同源（域名不同） https://kmac007.com:8080/2017/first.html 不同源（端口不同） 同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 跨域以及跨域的几种实现方式跨域指的是，突破同源策略，不同源之间进行数据传输或通信。 跨域有如下几种实现方式： JSONP document.domain window.postMessage CORS：跨域资源共享（Cross-origin resource sharing）等 JSONP在JS中我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。由于script标签不受同源策略的限制，可以通过script标签向服务器请求数据。而JSONP就是通过这个特性来实现的。 JSONP的原理是，在网页中动态添加一个script标签，src指向接口地址，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据包裹在一个指定名字的回调函数里传回来。 如: script标签的src指向 ‘kmac007.com/getData?callback=jsonp’,以jsonp(data)形式的返回数据，调用页面上的jsonp函数从而获取到了data 实现示例1234567891011121314//前端部分: function addScriptTag(src) &#123; var script = document.createElement('script'); script.src = src; document.body.appendChild(script); &#125; window.onload = function () &#123; addScriptTag('http://kmac007.com/getData?callback=jsonp'); &#125; function jsonp(data) &#123; console.log(data.name) &#125; 服务器收到这个请求后，会将数据放在回调函数的参数位置返回：12345678910111213141516//后端部分：app.get('/getData', function (req, res) &#123; var data = &#123; "name": "dk", "age": "23" &#125; var cb = req.query.callback if (cb) &#123; res.send(cb + '(' + JSON.stringify(data) + ')') &#125; else &#123; res.send(data) &#125;&#125;)/* 返回：json(&#123;"name":"dk","age":"23"&#125;)*/ 优点 很好的解决了跨域通信的问题，用户传递一个callback参数给服务器，服务器根据callback返回特定的callback包裹的数据，客户端可以随意定制自己的的函数处理返回的数据。 兼容性非常好，在非常古老的浏览器上也能很好的实现 缺点 JSONP只支持get请求而不支持其他HTTP请求，参数的形式只能做url拼接，后台取值会比较繁琐 存在安全隐患，动态插入&lt;script&gt;标签其实就是一种脚本注入。 document.domainCookie是服务器写入浏览器的一小段消息，只有同源的网页才能共享。但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享Cookie。 举例来说, A网页是http://www1.kmac007.com/a.html，B网页是html://www2.kmac007.com/b.html，只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = 'kmac007.com' 现在A网页中设置一个Cookie 1document.cookie = "test=1" 网页B中就可以读取这个Cookie 1var allCookie = document.cookie window.postMessage由HTML5引入的API,postMEssage()方法允许来自不同源的脚本采用异步方式进行有限通信。这个API为 window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 postMessage方法的第一个参数是具体的信息内容，第二个参数是接收信息的窗口源（origin）,即“协议+域名+端口”。也可以设为*，表示不限制域名，向所有窗口发送。 即父窗口与子窗口互相发送消息，通过message事件，监听对方的消息，实现跨域。 父窗口：123456789101112131415$('.main input').addEventListener('input', function () &#123; console.log(this.value); window.frames[0].postMessage(this.value, '*'); //向子窗口发送信息&#125;)window.addEventListener('message', function (e) &#123; $('.main input').value = e.data console.log(e.data); //监听子窗口发送信息的变化&#125;);function $(id) &#123; return document.querySelector(id);&#125; 子窗口：1234567891011121314$('#input').addEventListener('input', function()&#123; window.parent.postMessage(this.value, '*'); //向父窗口发送信息&#125;)window.addEventListener('message',function(e) &#123; $('#input').value = e.data console.log(e.data); //监听父窗口的发送的信息变化&#125;);function $(id)&#123; return document.querySelector(id);&#125; CORSCORS是一个W3C标准，全称是“跨域资源共享”(Cross-origin resource sharing)。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。 实现功能非常简单，只需要由服务器发送一个响应标头即可。它是通过客户端+服务端协作声明的方式来确保请求安全的。服务端会在HTTP请求头增加一系列HTTP请求参数（例如Acess-Control-Allow-Origin等），来限制哪些域的请求和哪些类型可以接受，而客户端在发起请求时必须声明自己的源(Origin)，否则服务器将不予处理，如果客户端不作声明，请求甚至会被浏览器直接拦截到不了服务端。服务端收到HTTP请求后会进行域的比较，只有同域的请求才会处理。 浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要满足以下两大条件，就属于简单请求：12345678910（1）请求方法是以下三种方法之一：- HEAD- GET- POST（2）HTTP的头信息不超过以下几种字段：- Accept- Accept-Language- Content-Language- Last-Event-ID- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理方式是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说就是在头信息中，增加一个Origin字段。而Origin字段说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，浏览器会返回一个正常的HTTP回应。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息 。如： 1234Access-Control-Allow-Origin: http://api.kmac007.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: showMesContent-Type: text/html; charset=utf-8 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求。浏览器先询问服务器，当前网页所在的域名是否在服务器的虚空名单之中，一次可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就会报错。 实现实例:12345678910111213141516171819//前端部分&lt;body&gt; &lt;button id="btn"&gt;点我&lt;/button&gt; &lt;script&gt; var btn = document.getElementById("btn") btn.addEventListener('click', function () &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var newLi = document.createElement('li') newLi.innerText = xhr.responseText document.body.appendChild(newLi) &#125; &#125; xhr.open('get', 'http://b.kmac007.com:8080/getData', true) xhr.send() &#125;) &lt;/script&gt;&lt;/body&gt; 1234567//后端部分app.get('/getData',function(req,res)&#123; var data = "are u ok" res.header("Access-Control-Allow-Origin","*") // 加入响应头Access-Control-Allow-Origin res.send(data)&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2FAjax.html</url>
    <content type="text"><![CDATA[Ajax是什么?有何作用 AJax为“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。 作用是：无需重新加载页面即可与服务器交换数据。 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。这种技术带来了不错的用户体验。 而传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 用JS发起请求的几个步骤1. 创建一个XMLHttpRequest对象()1var xhr = new XMLHttpRequest() 2. 监听请求成功后的变化1234567xhr.onreadystatechange = function() &#123; if (this.readyState== 4)&#123; if (xhr.status === 200 || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; &#125;&#125; xhr.responseText即服务器返回的内容（默认为字符串） 3. 设置请求参数1xhr.open("GET", "url", true) 4. 发送请求1xhr.send() 在jQuery.ajax中对以上进行了封装123$.get('url').then(function(response)&#123; //response即为响应内容&#125;) 点击按钮，使用 ajax 获取数据，防止重复点击可以使用状态锁，判断数据是否到来。状态锁初始值为true，当发起一次请求后状态锁值变为false，此时，若是未获得响应的情况下重复点击，函数均被返回，等到状态码变为4即数据接收完毕，状态锁值变为true。12345678910111213141516171819var isDataArrive = true //默认为truevar btn = document.getElementById("getData")btn.addEventListener('click', function () &#123; if (!isDataArrive) &#123; //如果数据没有到来 return &#125; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; isDataArrive = true // 收到响应 &#125; &#125; xhr.open() xhr.send() isDataArrive = false //停止再次发送请求&#125;) 简单封装一个 ajax 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//封装function ajax(opts) &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var results = JSON.parse(xhr.responseText) opts.success(results) &#125; if(xhr.status === 404)&#123; opts.error() &#125; &#125; &#125; var dataString = '' for (var key in opts.data) &#123; dataString += key + "=" + opts.data[key] + "&amp;" &#125; dataString = dataString.substr(0, dataString.length - 1) if (opts.type.toLowerCase() === "get") &#123; xhr.open("get", opts.url + "?" + dataString, true) xhr.send() &#125; if (opts.type.toLowerCase() === "post") &#123; xhr.open("post", opts.url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded") xhr.send(dataString) &#125;&#125;//调用document.querySelector('#btn').addEventListener('click', function() &#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: 'kmac007', password: 'kmac007' &#125;, success: function(ret) &#123; console.log(ret); // &#123;status: 0&#125; &#125;, error: function() &#123; console.log('出错了') &#125; &#125;)&#125;); 实现加载更多的功能，后端在本地使用server-mock来模拟数据前端部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;加载更多&lt;/title&gt; &lt;style&gt; ul, li &#123; margin: 0; padding: 0; &#125; #ct li &#123; width: 100%; list-style: none; padding: 10px; margin-top: 10px; cursor: pointer; border: 1px solid #ccc; &#125; #ct li:hover &#123; background-color: green; color: #fff; &#125; #btn &#123; border-radius: 5px; text-align: center; width: 80px; padding: 10px; margin: 10px auto; border: 1px solid palevioletred; color: palevioletred; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ct"&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;/ul&gt; &lt;div id="btn"&gt; 加载更多 &lt;/div&gt; &lt;script&gt; var btn = document.getElementById("btn") var ct = document.getElementById("ct") var pageIdx = 2 var isDataArrive = true btn.addEventListener('click', function (e) &#123; e.preventDefault() if (!isDataArrive) &#123; return &#125; isDataArrive = false ajax(&#123; url: '/loadMore', //接口地址 type: 'get', data: &#123; index: pageIdx, length: 6 &#125;, success: function (results) &#123; renderPage(results) &#125;, error: function () &#123; console.log("error") &#125; &#125;) &#125;) function renderPage(news) &#123; var fragment = document.createDocumentFragment() for (var i = 0; i &lt; news.length; i++) &#123; var node = document.createElement("li") node.innerText = news[i] fragment.appendChild(node) &#125; ct.appendChild(fragment) &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var results = JSON.parse(xhr.responseText) opts.success(results) pageIdx += 6 &#125; else &#123; opts.error() &#125; isDataArrive = true &#125; &#125; var dataStr = '' for (var key in opts.data) &#123; dataStr += key + "=" + opts.data[key] + "&amp;" &#125; dataStr = dataStr.substr(0, dataStr.length - 1) if (opts.type.toLowerCase() === "get") &#123; xhr.open("get", opts.url + "?" + dataStr, true) xhr.send() &#125; if (opts.type.toLowerCase() === "post") &#123; xhr.open("post", opts.url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded") xhr.send(dataStr) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端部分，采用server-mock12345678910//加载更多router.get('/loadMore', function (req, res) &#123; var curIdx = req.query.index var len = req.query.length var data = [] for (var i = 0; i &lt; len; i++) &#123; data.push('内容' + (parseInt(curIdx) + i)) &#125; res.send(data)&#125;) 前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？前后端开发联调需要注意的事情： 约定数据：需要传输的数据及其数据类型 约定接口：确定接口名称及请求响应的格式，请求的参数名称、响应的数据格式 根据这些约定整理成接口文档 如何mock数据：参照接口文档，使用假数据来验证接口和页面响应的正确性。 如果有线上接口，可以根据线上接口来测试 可以使用mock工具来mock数据。 也可以通过node express搭建本地服务器，写脚本提供临时数据。 也可以直接将mock数据写入代码中，但缺点是联调需要做的改动较多，接口文档变化需要手动刷新。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包、定时器与BOM]]></title>
    <url>%2F2017%2F%E9%97%AD%E5%8C%85%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8EBOM.html</url>
    <content type="text"><![CDATA[什么是闭包JavaScript变量作用域有两种，分别是全局的作用域和函数作用域，JavaScript函数的局部变量可以直接读取全局变量。而函数外部变量并不能读取函数内的局部变量，但是通过闭包，可以在函数外部访问到内部的变量。 JavaScript作用域链：子对象会一级一级的向上查找父对象的变量，父对象的所有变量对子对象都是可见的，反之则不成立。 123456789function foo(x) &#123; var local = 1 return function() &#123; console.log(x + local) &#125;&#125;var bar = foo(2)bar() 如上，1234var local = 1return function() &#123; console.log(x + local)&#125; 这就是一个闭包 即闭包指的是函数和函数内部能访问到的变量的总和。 闭包的作用： 暴露一个可以访问局部变量的函数 隐藏一个变量，不让其他人直接访问这个变量 闭包的应用场景写一个函数判断是否首次加载 123456789101112131415161718//判断是否首次加载function firstLoad() &#123; //声明一个_list，外部无法直接访问与修改_list var _arr = [] return function(id) &#123; if (_arr.indexOf(id) &gt;= 0) &#123; return false &#125; else &#123; _arr.push(id) return true &#125; &#125;&#125;var isFirstLoad = firstLoad()isFirstLoad(10)isFirstLoad(10) 修改代码让fnArr[i]() 输出 i。使用两种以上的方法1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log( fnArr[3]() ); // 输出10 代码的输出结果为1012345678910// 方法一var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; !function(i)&#123; fnArr[i]=function()&#123; return i; &#125; &#125;(i)&#125;console.log(fnArr[3]()); // 12345678910// 方法二var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = (function(i)&#123; return function()&#123; return i; &#125; &#125;(i));&#125;console.log(fnArr[3]()); // 12345678// 方法三var fnArr = [];for (let i = 0; i &lt; 10; i++) &#123; //使用ES6的let语法 fnArr[i] = function () &#123; return i; &#125;;&#125;console.log(fnArr[3]()); // 封装一个汽车对象，可以通过如下方式获取汽车状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var Car = (function () &#123; var speed = 0 function setSpeed(s) &#123; speed = s &#125; function getSpeed() &#123; console.log(speed) &#125; function accelerate() &#123; speed += 10 &#125; function decelerate() &#123; speed &gt; 0 ? speed -= 10 : speed &#125; function getStatus() &#123; if (speed &lt;= 0) &#123; console.log("stop"); speed = null &#125; else if (speed &gt; 0) &#123; console.log("running") &#125; &#125; return &#123; setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate();Car.decelerate();Car.getStatus(); //'stop';//Car.speed; //error 下面这段代码输出结果是? 为什么?123456789var a = 1;var a ;setTimeout(function()&#123; a = 2; console.log(a); //2&#125;, 0);console.log(a); //1a = 3;console.log(a); //3 输出结果为1,3,2 因为setTimeout()会在程序的最后执行，前面声明a并赋值，重复声明不会改变a的值, setTimeOut异步 下面这段代码输出结果是? 为什么?123456var flag = true;setTimeout(function()&#123; flag = false;&#125;,0) //原本会在程序的末尾执行，但由于while是个死循环，程序不会往下执行，故setTimeout也不会执行while(flag)&#123;&#125; //flag永远是true,死循环console.log(flag); //不会执行 下面这段代码输出？如何输出delayer: 0, delayer:1...（使用闭包来实现）1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;// 输出 0,1,2,3,4 delayer: 5, delayer: 5... 修改：123456789for (var i = 0; i &lt; 5; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log('delayer:' + i); &#125;, 0); console.log(i); &#125;)(i)&#125;// 输出0,1,2,3,4 delayer: 0, delayer: 1, delayer: 2, delayer: 3, delayer: 4, 如何获取元素的真实宽高使用window.getComputedStyle()方法123var ele = doutment.getElementById(&quot;test&quot;)window.getComputedStyle(ele).width //获取id为test元素的宽window.getComputedStyle(ele).height //获取id为test元素的高 URL如何编码解码？为什么要编码？JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent()区别 encodeURI方法不会对下列字符编码 ASCII字母 数字 ~!@#$&amp;*()=:/,;?+’ encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()’ 所以encodeURIComponent比encodeURI编码的范围更大。之所以要进行编码，是因为URL中有些字符会引起歧义。 补全如下函数，判断用户的浏览器类型123456789101112131415function isAndroid() &#123; return /Android/.test(window.navigator.userAgent)&#125;function isIphone() &#123; return /iPhone/.test(window.navigator.userAgent)&#125;function isIpad() &#123; return /iPad/.test(window.navigator.userAgent)&#125;function isIOS() &#123; return /iOS/i.test(window.navigator.userAgent)&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>BOM</tag>
        <tag>闭包</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2017%2FDOM%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[DOM0级事件和DOM2级事件 DOM0级事件处理程序是将一个函数赋值给一个事件处理程序属性。每个元素（包括window 和document）都有自己的事件处理程序属性，这些属性通常全部小写，如：onclick；同属性多次赋值的话，后面的属性会覆盖前面的属性。删除事件处理程序只需要将属性值设置为null即可，具有跨浏览器优势。这种方式添加的事件处理程序会在事件流的冒泡阶段处理。 DOM2级事件处理程序，定义了两个方法，用于处理指定和删除事件处理程序：addEventListener(), removeEventListener()。都接受3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值（默认为false）。最后一个布尔参数如果是true，表示在捕获阶段调用处理程序，而false表示在冒泡阶段调用事件处理程序。可以添加多个事件处理程序。但IE8及更早的版本不支持。 attachEvent与addEventListener的区别？区别如下： attachEvent()接受两个参数：事件处理程序名称与事件处理程序函数；而 addEventListener()接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（默认值为false可忽略）。 事件处理程序的执行顺序不同：通过attachEvent()给某元素添加多个对于同一事件的处理程序时，它们的执行顺序是按照最后添加的先执行。 对于addEventListener()的事件处理程序则是按照添加顺序执行。 由于IE8及更早版本只支持事件冒泡，所用通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段，而addEventListener()可以通过第三个参数布尔值来确定处理程序是在捕获阶段还是冒泡阶段调用。 作用域: 使用attachEvent()，事件处理程序会在全局作用域中运行，因此this等于window; 而addEventListener()的作用域是元素本身，this是指的是触发元素。 第一个参数不同：attachEvent()第一个参数为”on”+事件名，而addEventListener()的第一个参数为事件名。 IE事件冒泡与DOM2事件IE事件冒泡 对于IE事件冒泡：即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。如图，如果单击了页面中的元素，那么click事件就会按照图中1、2、3、4的顺序传播。 DOM事件流 对于DOM事件流：“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。当点击元素时，会按照如上图所示的顺序触发事件。 阻止事件冒泡与阻止默认事件 标准浏览器 阻止冒泡: e.stopPropagation() 阻止默认事件：e.preventDefault() IE浏览器 阻止冒泡：event.cancelBubble = true 阻止默认事件：event.returnValue = false 有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容12345678&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;kmac007&lt;/li&gt; &lt;li&gt;小站&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//todo ...&lt;/script&gt; 代码如下： 1234var myLi = document.querySelector(".ct");myLi.addEventListener("click", function (event) &#123; console.log(event.target.innerText);&#125;); 补全代码，要求： 当点击按钮开头添加时在这里是元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串. 当点击每一个元素li时控制台展示该元素的文本内容。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;kmac007&lt;/li&gt; &lt;li&gt;小站&lt;/li&gt;&lt;/ul&gt;&lt;input class="ipt-add-content" placeholder="添加内容" /&gt;&lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt;&lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt;&lt;script&gt; //你的代码 function $(id) &#123; return document.querySelector(id) &#125; var ct = $(".ct") var btnStart = $("#btn-add-start") var btnEnd = $("#btn-add-end") var iptContent = $(".ipt-add-content") ct.addEventListener('click', function (e) &#123; console.log(e.target.innerText) &#125;) btnStart.addEventListener('click', function () &#123; if (!iptContent.value) &#123; alert("请输入内容") return false &#125; else &#123; var newLi = document.createElement("li") newLi.innerText = iptContent.value ct.insertBefore(newLi, ct.childNodes[0]) &#125; &#125;) btnEnd.addEventListener('click', function () &#123; if (!iptContent.value) &#123; alert("请输入内容") return false &#125; else &#123; var newLi = document.createElement("li") newLi.innerText = iptContent.value ct.appendChild(newLi) &#125; &#125;)&lt;/script&gt; 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。12345678910111213141516171819202122232425262728&lt;ul class="ct"&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/Mourinho.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/ibr.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/rooney.png"&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class="img-preview"&gt;&lt;/div&gt;&lt;script&gt; //你的代码 function $(id) &#123; return document.querySelector(id) &#125; var ct = $(".ct") var pre = $(".img-preview") //鼠标移入事件 ct.addEventListener("mouseover", function (e) &#123; if (e.target.nodeName.toLowerCase() === "li") &#123; var img = document.createElement("img") img.src = e.target.getAttribute("data-img") pre.appendChild(img) &#125; &#125;) //鼠标移出事件 ct.addEventListener("mouseout", function (e) &#123; if (e.target.nodeName.toLowerCase() === "li") &#123; pre.innerHTML = '' &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>DOM</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作]]></title>
    <url>%2F2017%2FDOM%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[DOM对象的innerText和innerHTML有什么区别？ innerText返回元素内所包含的文本内容，在多层次的时候会按照元素的深浅顺序拼接其内容 innerHTML返回的是元素的HTML结构 elem.children和elem.childNodes的区别elem.children与elem.childNodes 两者都是返回子节点；前者返回的是节点集合后者返回指定节点的子节点的节点集合包括元素、文本、注释等 查询元素有几种常见的方法？ES5的元素选择方法是什么?1234567891011常见的方法有：1、getElementById()2、getElementsByTagName()3、getElementsByClassName()4、getElementsByName()ES5的元素选择方法是：1. querySelector()2. querySelectorAll() 如何创建一个元素？如何给元素设置属性？如何删除属性123var s = document.createElement("span") //创建元素s.setAttribute("name","DK") // 设置属性s.removeAttribute("name") //删除属性 如何给页面元素添加子元素？如何删除页面元素下的子元素?12element.appendChild() //给element添加子元素element.removeChild(child) //删除element元素下的子元素child element.classList有哪些方法？如何判断一个元素的 class 列表中是包含某个 class？如何添加一个class？如何删除一个class?12345add(class1, class2, ...) //在元素中添加一个或多个类名，如指定的类名已存在，则不会添加contains(class) //返回布尔值，判断指定的类名是否存在item(index) //返回类名在元素中的索引remove(class1, class2, ...) //移除元素中的一个或多个类名，移除不存在的类名不会报错toggle(class, true|false) //在元素中切换类名，第一个参数为要在元素中移除的类名，并返回false。如果类名不存在则会在元素中添加类名，并返回true。第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管类名是否存在。 利用contains()判断是否包含某个class,用add()和remove()添加和删除class 如何选中如下代码所有的li元素？ 如何选中btn元素？12345678&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt; 选中所有的li:12document.getElementsByTagName('li')document.querySelectorAll('li') 选中btn元素:1234document.getElementsByTagName("button")[0]document.getElementsByClassName("btn")[0]document.querySelector(".btn")doucument.querySelectorAll(".btn")[0]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型及对象拷贝]]></title>
    <url>%2F2017%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D.html</url>
    <content type="text"><![CDATA[引用类型与非引用类型非引用类型：Undefined, Null, Number, String, Boolean 引用类型有: Function, Object, Array, Date, RegExp 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //false 这里是判断obj1与obj2是否指向相同的对象console.log(obj1 = obj2); //&#123;a:1, b:2&#125; 使obj1的指针指向obj2console.log(obj1 == obj2); //true 由于obj1, obj2指向相同的对象，所以为true 如下代码输出什么? 为什么12345678910111213141516171819var a = 1var b = 2var c = &#123; name: 'dk', age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = 'hello'd[2]['age'] = 3console.log(aa) //1, 将a的值赋予aaconsole.log(bb) //2, 将b的值赋予bbconsole.log(cc) //&#123; name: 'hello', age: 3 &#125;, cc与c指向同一个对象,改变c与会使cc改变console.log(dd) // [1, 2, &#123; name: 'hello', age: 3 &#125;], dd与d指向同一个对象,改变d同样会使dd改变 如下代码输出什么? 为什么123456789101112131415var a = 1var c = &#123; name: 'dk', age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a)f2(c)f1(c.age)console.log(a) //1, 因为f1是按值传递，仅是将值传递进去，不会改变全局变量aconsole.log(c) //&#123; name: 'dk', age: 3 &#125;, f2(c)是引用传递，变量指针指向obj, 会改变c中的值，而f1(c.age)为值传递，同理不会改变c 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt;= 0) &#123; arr.splice(i, 1); filter(arr); &#125; &#125;&#125;filter(arr)console.log(arr) // [3,1,2] 过滤如下数组，只保留正数，原数组不变，生成新数组12345678910111213var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = [] for(var i in arr) &#123; if(arr[i] &gt; 0) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] 对象深拷贝的几种方式 注意，ES6中Object.assign为浅拷贝 12345678910111213141516171819202122232425262728293031var obj = &#123; name: "robert", age: 3, child: &#123; name: "bob", age: 3 &#125;&#125;/*方法一*/function deepCopy1(obj) &#123; var newObj = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] !== 'object') &#123; newObj[key] = obj[key] &#125; else &#123; newObj[key] = deepCopy1(obj[key]) &#125; &#125; &#125; return newObj&#125;var obj2 = deepCopy1(obj)console.log(obj2)/*方法二*/function deepCopy2(obj) &#123; var newObj = JSON.parse(JSON.stringify(obj)) return newObj&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>引用类型</tag>
        <tag>对象拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[正则表达式常用字符及其含义 字符 含义 \d 数字字符 \w 单词字符，字母、数字下划线 \s 空白符 [a-zA-Z0-9]] 任意字母a-z,A-Z和数字 \b 单词边界 . 除了回车符和换行符之外的所有字符 * 出现零次或多次（任意次） + 出现一次或多次（至少出现一次） ? 出现零次或一次（最多出现一次） x{3} x出现3次 ^ 以XXX开头 $ 以XXX结尾 写一个函数trim(str)，去除字符串两边的空白字符123function trim(str)&#123; return str.replace(/^\s+|\s+$/g,'')&#125; 写一个函数isEmail(str)，判断用户输入的是不是邮箱1234function isEmail(str) &#123; var reg = /^\w+@\w+\.\w+$/ return reg.test(str)&#125; 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号1234function isPhoneNum(str) &#123; var reg = /^1[35789]\d&#123;9&#125;$/ return reg.test(str)&#125; 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）1234function isValidUsername(str)&#123; var reg = /^\w&#123;6,20&#125;$/ return reg.test(str)&#125; 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，只包括大写字母、小写字母、数字、下划线，且至少至少包括两种）12345678910111213141516function isValidPassword(str)&#123; if(str.length&lt;6||str.length&gt;20||/[\W]/.test(str)) &#123; return false &#125;else &#123; var count = 0 if(/[a-z]/.test(str)) count++ if(/[A-Z]/.test(str)) count++ if(/[0-9]/.test(str)) count++ if(/[_]/.test(str)) count++ if(count&gt;=2)&#123; return true &#125;else&#123; return false &#125; &#125;&#125; 写一个正则表达式，得到如下字符串里所有的颜色123var reg = /#[a-fA-F0-9]&#123;6&#125;/gvar subj = "color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee "console.log( subj.match(reg) ) // ['#121212', '#AA00ef'] 下面代码输出什么? 为什么? 改写代码，让其输出[“”hunger””, “”world””].12345678var str = 'hello "hunger" , hello "world"';var pat = /".*"/g;str.match(pat);//[""hunger" , hello "world""]//原因是贪婪模式，量词在默认下尽可能多的匹配//修改如下：var str = 'hello "hunger" , hello "world"';var pat = /".*?"/g;str.match(pat);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math数组及Date相关操作]]></title>
    <url>%2F2017%2FMath%E6%95%B0%E7%BB%84%E5%8F%8ADate%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[Math写一个函数，返回从min到max之间的随机整数，包括min不包括max123function getRandom(min, max) &#123; return Math.floor(min + Math.random() * (max - min))&#125; 写一个函数，返回从min都max之间的 随机整数，包括min包括max123function getRandom(min, max) &#123; return Math.floor(min + Math.random() * (max - min + 1))&#125; 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。12345678910111213var oldStr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"function getRandStr(len) &#123; //补全函数 var strArr = oldStr.split('') var randStr = '' for (var i = 0; i &lt; len; i++) &#123; var strKey = Math.floor(Math.random() * oldStr.length) randStr += strArr[strKey] &#125; return randStr&#125;var str = getRandStr(10); // 0a3iJiRZap 写一个函数，生成一个随机 IP 地址，一个合法的 IP 地址为 0.0.0.0~255.255.255.255123456789function getRandIp() &#123; var ipArr = [] var len = 4 for (var i = 0; i &lt; len; i++) &#123; ipArr[i] = Math.floor(Math.random() * (255 + 1)) &#125; return ipArr.join('.') &#125; getRandIp() 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff1234567891011function getRandColor() &#123; var str = "ABCDEF0123456789" var colorArr = str.split('') var len = 6 var colorStr = '' for (var i = 0; i &lt; len; i++) &#123; colorStr += colorArr[Math.floor(Math.random() * (colorArr.length))] &#125; return '#' + colorStr&#125;getRandColor() 数组数组方法里push、pop、shift、unshift、join、splice分别是什么作用？用 splice函数分别实现push、pop、shift、unshift方法push: 向数组的末尾添加一个或更多元素，并返回新的数组长度。 pop: 删除并返回数组的最后一个元素 shift: 删除并返回数组的第一个元素 unshift: 向数组的开头添加一个或更多元素，并返回新的长度。 join: 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 splice: 删除元素，并向数组添加新元素。 用splice实现push:1arr.splice(arr.length,0,item) 用splice实现pop:1arr.splice(arr.length-1,1) 用slice实现unshift:1arr.splice(0,0,item) 用slice实现shift:1arr.splice(0,1) 写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作123456789function squareArr(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] * arr[i] &#125; return arr&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] 写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变12345678910111213function filterPositive(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (typeof arr[i] === "number" &amp;&amp; arr[i] &gt; 0) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;var arr = [3, -1, 2, 'hello', true]var newArr = filterPositive(arr)console.log(newArr) //[3, 2]console.log(arr) //[3, -1, 2, 'hello', true] Date写一个函数getChIntv，获取从当前时间到指定日期的间隔时间1234567891011121314var timeStr = getChIntv("2017-05-01");function getChIntv(timeStr) &#123; var targetTime = new Date(timeStr).getTime() - 1000 * 60 * 60 * 8 var currentTime = Date.now() var offsetTime = targetTime - currentTime var days = parseInt(offsetTime / (1000 * 60 * 60 * 24)) var hours = parseInt(offsetTime % (1000 * 60 * 60 * 24) / (1000 * 60 * 60)) var mins = parseInt(offsetTime % (1000 * 60 * 60 * 24) % (1000 * 60 * 60) / (1000 * 60)) var seconds = parseInt(offsetTime % (1000 * 60 * 60 * 24) % (1000 * 60 * 60) % (1000 * 60) / 1000) return "距五一还有:" + days + "天" + hours + "小时" + mins + "分" + seconds + "秒"&#125;console.log(timeStr); // 距五一还有:11天7小时26分28秒 把hh-mm-dd格式数字日期改成中文日期1234567891011121314var str = getChsDate('2015-01-08');function getChsDate(timeStr) &#123; var dist = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二", "十三", "十四", "十五", "十六", "十七", "十八", "十九", "二十", "二十一", "二十二", "二十三", "二十四", "二十五", "二十六", "二十七", "二十八", "二十九", "三十", "三十一"]; var arr = timeStr.split('-') var year = arr[0] var month = arr[1] var day = arr[2] var chYear = dist[parseInt(year[0])] + dist[parseInt(year[1])] + dist[parseInt(year[2])] + dist[parseInt(year[3])] var chMonth = dist[parseInt(month)] var chDay = dist[parseInt(day)] return chYear + "年" + chMonth + "月" + chDay + "日"&#125;console.log(str); // 二零一五年一月八日 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串:12345678910111213141516171819function friendlyDate(time) &#123; var now = Date.now() var offsetTime = (now - time) / 1000 / 60 if (offsetTime &lt; 1) &#123; return parseInt(offsetTime * 60) + "刚刚" &#125; else if (offsetTime &gt;= 1 &amp;&amp; offsetTime &lt; 60) &#123; return parseInt(offsetTime) + "分钟前" &#125; else if (offsetTime &gt;= 60 &amp;&amp; offsetTime &lt; 60 * 24) &#123; return parseInt(offsetTime / 60) + "小时前" &#125; else if (offsetTime &gt;= 60 * 24 &amp;&amp; offsetTime &lt; 60 * 24 * 30) &#123; return parseInt(offsetTime / 60 / 24) + "天前" &#125; else if (offsetTime &gt;= 60 * 24 * 30 &amp;&amp; offsetTime &lt; 60 * 24 * 39 * 12) &#123; return parseInt(offsetTime / 60 / 24 / 30) + "月前" &#125; else if (offsetTime &gt;= 60 * 24 * 39 * 12) &#123; return parseInt(offsetTime / 60 / 24 / 30 / 12) + "年前" &#125;&#125;var str = friendlyDate('1492593606284') // 1分钟前var str2 = friendlyDate('1422583606284') //2年前]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Math</tag>
        <tag>Date</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串与JSON相关操作]]></title>
    <url>%2F2017%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EJSON%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[使用数组拼接出如下字符串1&quot;&lt;dl class=&quot;product&quot;&gt;&lt;dt&gt;女装&lt;/dt&gt;&lt;dd&gt;短款&lt;/dd&gt;&lt;dd&gt;冬季&lt;/dd&gt;&lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt;&quot; 12345678910111213141516var prod = &#123; name: '女装', styles: ['短款', '冬季', '春装']&#125;function getTplStr(data) &#123; var arr = [] arr.push('&lt;dl class="product"&gt;') arr.push('&lt;dt&gt;' + data.name + '&lt;/dt&gt;') for (key in data['styles']) &#123; arr.push('&lt;dd&gt;' + data['styles'][key] + '&lt;/dd&gt;') &#125; arr.push("&lt;/dl&gt;") return arr.join('')&#125;var result = getTplStr(prod) //result拼接后的字符串 写出两种以上声明多行字符串的方法12345678910111213141516171819202122232425262728293031/*使用\n转义字符回车*/var str1 = "line1\nline2\nline3\n"console.log(str1)/*使用反斜杠转义*/var str2 = "line1\ line2\ line3\"console.log(str2)/*连接运算符(+)*/var str3 = "line1" + "line2" + "line3"console.log(str3)/*使用多行注释，生成多行字符串*/var str4 = (function()&#123;/* line1 line2 line3*/&#125;).toString().split('\n').slice(1,-1).join('\n')/*使用ES6的字符串扩展*/var str5 = ` line1 line2 line3`console.log(str5) 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是12345678910function isPalindrome(str) &#123; if (typeof str === "string") &#123; var newStr = str.toLowerCase().split('').reverse().join('') if(newStr === str.toLowerCase()) &#123; console.log("是回文") &#125;else &#123; console.log("不是回文") &#125; &#125;&#125; 写一个函数，统计字符串里出现出现频率最多的字符1234567891011121314151617181920function isMost(str) &#123; var dict = &#123;&#125; for (var i = 0; i &lt; str.length; i++) &#123; if(dict[str[i]]) &#123; ++dict[str[i]] &#125;else&#123; dict[str[i]] = 1 &#125; &#125; var count = 0 var maxValue for(var key in dict)&#123; if(dict[key] &gt; count)&#123; maxValue = key count = dict[key] &#125; &#125; //如果出现次数最多的字符不止一个，则加多一层循环 return maxValue + ":" + count&#125; 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如12camelize("background-color") == 'backgroundColor'camelize("list-style-image") == 'listStyleImage' 代码如下:12345678function camelize(str) &#123; var arr = str.toLowerCase().split('-') var newStr = arr[0] for (var i = 1; i &lt; arr.length; i++) &#123; newStr += (arr[i].charAt(0).toUpperCase() + arr[i].substring(1)) &#125; return newStr&#125; 写一个 ucFirst函数，返回第一个字母为大写的字符1ucFirst(&quot;hunger&quot;) == &quot;Hunger&quot; 代码如下：123function ucFirst(str) &#123; return str.charAt(0).toUpperCase() + str.substring(1)&#125; 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如12truncate("hello, my name is kmac007", 10) == "hello, thi...";truncate("hello world", 20) == "hello world" 代码如下:1234567function truncate(str, maxlength) &#123; if (str.length &gt; maxlength) &#123; return str.substring(0, maxlength) + "..." &#125; else &#123; return str &#125;&#125; JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集.JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 严格的JavaScript对象表示法表示结构化的数据。具体写法是：数据在名称/值对中；数据由逗号分隔；花括号保存对象；方括号保存数组 JSON 数据的书写格式是：名称/值对，名称/值对组合中的名称写在前面（在双引号中），值对写在后面(同样在双引号中)，中间用冒号隔开：值（value）可以是双引号括起来的字符串（string）、数值(number)、boolean、 null、对象（object）或者数组（array）。这些结构可以嵌套。 window.JSON是浏览器内置对象其中JSON.parse()表示把字符串解析为JSON对象，而JSON.stringify()表示将JSON对象解析为字符串 eval() 可以把字符串转为JSON 但不推荐使用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>字符串</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数与函数作用域]]></title>
    <url>%2F2017%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[函数声明与函数表达式的区别函数声明与函数表达式的区别在于: 函数声明是function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。如： 123function sayHi() &#123; console.log('hi');&#125; 而函数表达式采用的是变量赋值的写法：123var sayHi = function() &#123; console.log('hi');&#125; 这种写法将一个匿名函数赋值给变量，这个匿名函数又称为函数表达式。 由于函数声明前置，对于函数声明不必放到调用的前面，而函数表达式必须放到调用的前面。 变量声明前置与函数声明前置在一个作用域下，var 声明的变量和function 声明的函数会前置。 变量声明前置：使用var声明变量，变量声明会被提前到函数体的顶部，初始值为undefined而变量赋值操作留在原来的位置。 函数声明前置：采用function命令声明函数时，整个函数会被提升到当前作用域顶部，因此在声明函数之前调用函数也是可行的。 arguments 由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments为类数组对象，无法直接使用Aarry对象上的方法。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 但在严格模式下： 不允许对arguments赋值 1arguments++; // 语法错误 arguments不再追踪参数的变化 1234567891011 function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; "use strict"; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 函数重载的模拟JS没有重载机制，但我们可以模仿重载。 123456789101112131415function sum() &#123; if(arguments.length === 2) &#123; return arguments[0] + arguments[1]; &#125;else if(arguments.length === 3) &#123; return arguments[0] + arguments[1] + arguments[2]; &#125;else if(arguments.length === 4) &#123; return arguments[0] + arguments[1] + arguments[2] + arguments[3]; &#125;else &#123; return 0; &#125;&#125;sum(1,2); //3sum(1,2,3); //6sum(1,2,3,4); //10 立即执行函数表达式立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行；立即执行函数(immediate function)术语不是在ECMAScript标准中定义的，但它很短有助于描述和讨论模式；这种模式有一些几部分组成： 使用函数表达式定义一个函数(函数声明不能起作用) 在结尾加上一对括号，让函数立即被执行 将整个函数包裹在一对括号中(只有在你不将函数赋值给一个变量的时候才需要) 主要的作用是：隔离作用域。 相关面试题求n!，用递归来实现 123456 function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; return n * factorial(n-1);&#125; 写一个函数，返回参数的平方和1234567891011function sumOfSquares()&#123; var sum = 0; for(var i = 0; i &lt; arguments.length; i++) &#123; sum += Math.pow(arguments[i],2); &#125; return sum;&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result2) //10 变量声明提升123456789console.log(a);var a = 1;console.log(b);/* 输出： undefined b is not defined 原因是a声明前置，初始值为undefined，而b并没有声明*/ 函数声明提升12345678910111213141516 sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;;/* 输出： hello world sayAge is not a function 原因是sayName函数声明前置 而sayAge采用的是函数表达式的形式，必须要声明后才能调用*/ 如下代码输出什么? 写出作用域链查找过程伪代码12345678910111213141516171819202122232425262728293031323334353637383940var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;//作用域链过程伪代码：globalContext = &#123; AO: &#123; x: 10 foo: function bar: function &#125; Scope:null&#125;//声明foo时得到下面foo.[[scope]] = globalContext.AO//声明bar.[[scope]] = globalConetxt.AO//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 &#125; scope: globalConetext.AO&#125;//进入foo的执行上下文fooConetxt = &#123; AO: &#123; &#125; scope: globalConetext.AO&#125;故输出为： 10 如下代码输出什么? 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435var x = 10;bar()function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30; foo: function &#125; scope: globleContext.AO&#125;//进入foo的执行上下文fooContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;结果输出为: 30 以下代码输出什么? 写出作用域链的查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10;bar()function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125;//作用域链的查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 (anonymous): function &#125; scope: globleContext.AO&#125;//进入匿名函数执行上下文anonymousContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;所以最后输出: 30 以下代码输出什么？ 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; a: 1 fn: function fn3: function &#125; scope: null&#125;//声明fn时:fn.[[scope]]=globalContext.AO//声明fn3时:fn3.[[scope]]=globalContext.AO//开始进入fn的执行上下文fnContext = &#123; AO: &#123; a: undefined //输出undefined,变量声明提前 fn: function &#125; scope:globalContext.AO&#125;//声明a后fnContext = &#123; AO: &#123; a: 5 //输出5 fn: function &#125; scope: globalContext.AO&#125;//a++fnContext = &#123; AO: &#123; a: 6 fn: function &#125; scope: globalContext.AO&#125;//进入fn3的执行上下文fn3Context = &#123; Ao: &#123; &#125; scope: globalContext.AO //输出1 此后全局作用域下a:200&#125;//进入fn2的执行上下文fn2Context = &#123; AO: &#123; &#125; scope: fnContext.AO //输出6 此后fnContext.AO作用域下a:20&#125;//输出20 此后全局作用域下a:200//输出200即输出结果为：undefined 5 1 6 20 200]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种方式实现元素的垂直居中]]></title>
    <url>%2F2017%2F%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html</url>
    <content type="text"><![CDATA[HTML结构 123&lt;div class="container"&gt; &lt;div class="box"&gt;垂直居中&lt;/div&gt;&lt;/div&gt; flexbox布局1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; table-cell1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: table-cell; vertical-align: middle; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; 绝对定位负margin1234567891011121314151617.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; margin-left: -25px; margin-top: -25px;&#125; translate12345678910111213141516.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 与绝对定位负边距相似 绝对定位和0123456789101112131415161718.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0;&#125; 绝对定位，margin: auto; top, left, bottom, right均设为0, 子元素margin会撑开形成垂直居中 伪元素与inline-block123456789101112131415161718192021.container &#123; background-color: red; width: 200px; height: 200px; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; display: inline-block; vertical-align: middle;&#125;.container::after &#123; content: &apos;&apos;; display: inline-block; width: 0; height: 100%; vertical-align: middle;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[CSS hackCSS hack由于不同厂商的浏览器，比如IE, Safari, firefox, chorme，或同一厂商不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此能够导致生成页面效果不一样，得不到所需要的效果。这个时候我们需要针对不同浏览器写不同的CSS，让它能够同时兼容不同的浏览器，能在不同浏览器中也能得到我们想要的页面效果。 浏览器兼容的思路要不要做 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本角度（有无必要做某件事情） 做到什么程度 让哪些浏览器支持哪些效果 如何做 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、repond.js、css reset、normalize.css、Modernizr)、postCSS 条件注释、CSS hack、js能力检测做一些修补 列举5种以上浏览器兼容的写法 条件注释条件注释（Conditional comments）对IE的版本和IE非IE有优秀的区分能力，是WEB设计中常用的hack方法。 1234567891011&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt;用于 IE9 &lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt; 用于 IE7或更低版本 &lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;用于 IE8 或更高版本 &lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;用于 IE9 以下版本&lt;![endif]--&gt;&lt;!--[if !IE]&gt; --&gt;用于非 IE &lt;!-- &lt;![endif]--&gt;使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 CSS属性前缀法属性前缀法(即类内部Hack)：例如 IE6能识别下划线””和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识 123456.box&#123; color: red; _color: blue; /*ie6*/ *color: pink; /*ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 选择器前缀法（即选择器Hack） 例如 12IE6能识别*html .class&#123;&#125;，IE7能识别*+html .class&#123;&#125;或者*:first-child+html .class&#123;&#125;。 浏览器前缀 -webkit- ，针对safari，chrome浏览器的内核CSS写法 -moz-，针对firefox浏览器的内核CSS写法 -ms-，针对ie内核的CSS写法 -o-，针对Opera内核的CSS写法123456.box &#123; -moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; 4. 以下工具/名词是做什么的 条件注释 条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 IE Hack 针对IE浏览器编写不同的CSS以达到让IE正常解析CSS。 js 能力检测 识别浏览器的能力而不是识别特定的浏览器。只需根据浏览器支持的功能给出解决方案。 html5shiv.js 用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.js 用于为 IE6-8 以及其它不支持 CSS3 -媒体查询功能的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计。 css reset 去除浏览器的默认样式。 normalize.css Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 Modernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。 postCSS 它可以被理解为一个平台，可以让一些插件在上面跑，它提供了一个解析器，可以将CSS解析成抽象语法树，通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer，它可以帮我们处理兼容问题，只需正常写CSS，autoprefixer可以帮我的自动生成兼容性代码 查询属性兼容性http://caniuse.com/]]></content>
      <categories>
        <category>兼容性</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的CSS布局]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[五种方式实现三栏布局采用五种方式实现横向左右定宽，中间自适应的三栏布局 浮动 左右模块各自向左右浮动，并设置中间部分的左右margin值缺点是要按照left,right,main这样的顺序写HTML。 绝对定位 实用。 flexbox布局 要考虑兼容性的问题，对于移动端我一般采用这种方式来进行三栏布局。 table布局 缺点：无法设置main与两边的间隔 grid布局 缺点：兼容性有点尴尬啊。。 单栏布局 圣杯布局 main先加载，三个部分均左浮动，left和right设置负margin与main处在同一行，再通过相对定位调整位置。缺点是当页面缩小，页面结构会乱。 对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。 双飞翼布局 给main一个包裹层，设置左右margin，三个部分均浮动，其中左右定宽，中间100%,左右通过负margin回到合适的位置。 同样的，对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F%E6%B5%85%E6%9E%90%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?浮动的特征是使元素脱离普通流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素才停下来； 对父容器的影响: 父容器中的元素浮动后，脱离普通流会使得父容器失去高度； 对其他浮动元素的影响： 如果是同一方向浮动，相邻的浮动元素会并列在同一行，空间不够，会换到下一行 对普通元素的影响： 浮动元素会脱离普通流，普通元素会占据它原有的空间，从而会出现浮动元素覆盖普通元素 对文字的影响： 文字可以感知的浮动元素的存在，文字会在浮动元素周围形成环绕效果 清除浮动指什么? 如何清除浮动? 两种以上方法 清除浮动指的是通过clear属性解决由元素浮动引起的父容器的塌陷问题。 清楚浮动的方法： 方法一：父级元素定义：overflow: hidden; 方法二：使用伪元素 12345.container::after &#123; content: ''; display: block; clear: both;&#125; 方法三：在父元素末尾添加一个空div,设置样式clear: both (与方法二类似) 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ static: 默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明） relative: 生成相对定位元素，相对于元素本身正常位置进行定位。 absolute: 脱离普通流，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位,元素的位置通过 left, top, right 以及 bottom 属性进行规定 fixed: 绝对定位，脱离普通流，相对于浏览器窗口进行定位。元素的位置通过 left, top, right 以及 bottom 属性进行规定 sticky: CSS3新属性，表现类似position: relative和position: fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置 z-index 有什么作用? 如何使用?z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。元素可拥有负的 z-index 属性值。 应用 ：元素脱离了普通流，覆盖了普通元素，要修改显示顺序，可以为两者添加z-index属性值，其中属性值越大，显示的越靠前。 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别 position: relative: 相对于自身偏移，不脱离普通流，仍占据原有空间，不影响其他元素 负margin: 除了让元素自身发生偏移还影响其它普通流中的元素。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC(Block formatting context)直译为“块级格式化上下文 ”。BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。同时BFC任然属于文档中的普通流。 如何生成BFC：当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context float: 除了none以外的值 overflow除了visible意外的值（hidden, auto, scroll） display(table-cell, table-caption, inline-block) position(absolute, fixed) BFC的作用 阻止边距折叠： 我们知道在一般情况下，两个上下相邻的盒子会折叠它们垂直方向接触到的边距，这种情况只会发生在同一个Block Formatting Context中。换句话说，在同一个布局环境中（Block Formatting Context）是边距折叠的必要条件。这也就是为什么浮动的元素和绝对定位元素不会发生边距折叠的原因（当然还有很多种情况也不会折叠）。 可以包含浮动元素如: 阻止元素被浮动覆盖，如: 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。即：两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠 当然负margin的情况下也会出现margin合并的现象。 不让相邻元素外边距合并： 浮动元素、inline-block元素、绝对定位元素不会和垂直方向上其他元素的margin折叠(这里指的是上下相邻的元素) 创建了格式化上下文的元素，不和它的子元素发生margin折叠（这里指的是BFC的元素和它的子元素不会发生折叠）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>浮动</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些？ 块级元素：div, p, h1-h6, table, form, ul, li, ol, address, article, aside, audio, blockquote, canvas,header,footer等 行内元素: span, a, input, button, lable, select, textarea, em, br, img, strong 区别： 行内元素只能容纳行内元素和文本。而块级可以容纳块级元素和行内元素。 块级元素可以设定宽高，而行内元素不可以。 块级元素独占一行，而行内元素可以与其它行内元素共同处在一行。 行内元素的默认宽度为内容的宽度，块级元素默认宽度与浏览器窗口宽度一致 什么是 CSS 继承? 哪些属性能继承，哪些不能？ CSS继承: 子元素继承了父元素的CSS属性。 不可继承属性：display, margin, border, padding, background, width, height, overflow, z-index, float, position, vertical-align 所有元素可继承：visibility和cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中? 块级元素水平居中：给块级元素设定宽高,margin: 0 auto; 多个块级元素可以使用inline-block和flex 行内元素: text-align: center; 用 CSS 实现一个三角形 单行文本溢出加 …如何实现?12345.box &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; px, em, rem 有什么区别,如何理解dpr? px: 相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em: 指的是相对于其父级元素的大小，即倍数。 rem: 相对于根html元素的大小，即倍数。 dpr: 设备像素比。设备像素比 = 物理像素/设备独立像素(在某一方向上，x或y)，桌面端,CSS的1个像素都是对应着电脑屏幕的1个物理像素。而如果DPR为2时，CSS的1像素就会对应2物理像素。 解释下面代码的作用?为什么要加引号?字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 字体大小：12px 字体行距：1.5倍 字体选择的优先级从高到低：tahoma -&gt; … -&gt; sans-serif 字体描述需要加引号的情况，常见有下面几种： 字体描述使用的中文 字体描述使用英文，中间有空格 字体描述使用unicode编码\5b8b\4f53 是unicode编码模式，表示“宋体” 控制台中输入：escape(“字体”)将字体中文转换为unicode编码格式 常见样式实现按钮 三角形 实现Card text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是使得元素中的文本水平居中。作用在父元素上，能让行内元素以及块级元素中display为inline和inline-block元素居中。 IE 盒模型和W3C盒模型有什么区别? IE盒模型的宽度和高度包含border,padding和content 即：box-sizing: border-box; W3C盒模型只包含content部分的宽高 默认: box-sizing: content-box; *{ box-sizing: border-box;}的作用是什么？设置为以border,padding,content为宽高的盒模型。 line-height: 2和linde-height: 200%有什么区别？line-height: 2 表示根据子元素自己字体的大小乘以2来计算行高，而line-height: 200% 表示根据父元素的字体大小计算行高，并且子元素会继承父元素的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?inline-block使元素具有内联的特性时， 内容又具有块级元素的特性，可以设置宽高等； 去除缝隙有两种方法： 1.去除两元素间的空白字符， 2.将父元素的字体大小设置为0，再分别设置它们的字体大小； 高度不一样时，对具有inline-block属性的元素使用vertical-align: top使其对其。 CSS sprite 是什么?CSS精灵，指的是将多张图片拼接在一起，通过改变background-position来改变显示出来的图片，达到减少HTTP请求，提高页面性能的效果。 让一个元素”看不见”有几种方式？有什么区别?1234opacity: 0; 使元素变得透明，仍处在页面上display: none; 使元素在页面上消失,不占用空间visibility: hidden; 使元素不可见，但仍在页面上占据空间background-color: rgba(0, 0, 0, 0.2) 只是背景色透明]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class和id的使用场景？12class 用于选择页面上带相同类属性的元素，可以有多个id 它是唯一的，选择页面上唯一匹配id属性的元素 CSS选择器常见的有几种？1234567891011121. 元素选择器 如：p, h1, span2. 类选择器 .class-name3. id选择器 #id-name4. 通配选择器 *5. 属性选择器 E[attr], E[attr=value]等6. 组合选择器 E,F 多元素选择器 E F 后代选择器 E&gt;F 子元素选择器 E+F 相邻兄弟选择器 E~F 普通相邻选择器7. 伪类选择器 E:first-child, E:hover, E:nth-child(n)等8. 伪元素选择器 E::before, E::after 3. 选择器的优先级是怎样的?对于复杂场景如何计算优先级？要了解选择器的优先级，必须先知道CSS的特殊性，特殊性即CSS的优先级，而特殊性值的决定了CSS的优先级。如下：123456选择器的特殊性值表述为4个部分，用0,0,0,0表示。1. ID选择器的特殊性值，加0,1,0,0。2. 类选择器，属性选择器的特殊性值，加0,0,1,0。3. 元素和伪元素的特殊性值, 加0,0,0,1。4. 通配选择器*对特殊性没有贡献，即0,0,0,0。5. 最后一个比较特殊一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，可以用1,0,0,0表示。 场景下，如：12345678910111213&lt;body&gt; &lt;div class="demo"&gt; &lt;a href="#"&gt;demo&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; div a &#123; color: blue; /*这里的优先级为0,0,0,2*/ &#125; .demo a &#123; color: red; /*这里的优先级为0,0,1,1 故这个优先级较高*/ &#125;&lt;/style&gt; 再者，1,0,0,0是要比0,99,99,99优先级要高的，因此我们可以得出常见的选择器的优先级为：1234561. !important: 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式2. 内联样式3. ID选择器4. 类选择器，属性选择器5. 元素和伪元素选择器6. 通配选择器 4.a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？ css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性，根据（3）的优先级计算规则决定哪条规则起作用，当特殊性值也一样的时候，css规则会按顺序排序，后声明的规则优先级高 一个链接只有访问和未访问的状态，因此 :link 与 :visited 谁前谁后都可以。要保证点击后即active有样式变化，:active必须要覆盖:hover，因此:active要在:hover之后。要保证鼠标滑过有效果，:hover必须要在:link和:visited后。因此一般的顺序为： a:link a:visited a:hover a:active 有人将这个LVHT(LoVe HAte)称为“爱恨原则”。 5. 以下选择器分别是什么意思?123456789101112131415161718#header&#123; id为header的元素&#125;.header&#123; class为header的元素&#125;.header .logo&#123; class为header的所有class为logo的后代元素&#125;.header.mobile&#123; class同时包含header和mobile的元素&#125;.header p, .header h3&#123; class为header的后代元素中所有的p和h3元素&#125;#header .nav&gt;li&#123; id为header后代元素中class为.nav的子元素li&#125;#header a:hover&#123; id为header后代元素中a的伪类:hover&#125;#header .logo~p&#123; id为header的后代元素中与class为logo同级的p元素&#125;#header input[type="text"]&#123;&#125; id为header后代中type="text"的input的元素 列出你知道的伪类选择器 :hover :link :visited :active :focus :checked :enabled :first-of-type :first-child :nth-child(n) div:first-child和div:first-of-type的作用和区别 div:first-child 指的是当前元素父元素下的第一个子元素 div:first-of-type指的是当前元素父元素下拥有相同标签的第一个子元素 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;ct&quot;&gt; &lt;p class=&quot;item1&quot;&gt;aa&lt;/p&gt; &lt;h3 class=&quot;item1&quot;&gt;bb&lt;/h3&gt; &lt;h3 class=&quot;item1&quot;&gt;ccc&lt;/h3&gt; &lt;/div&gt; 原因是: .item1:first-child匹配了类为.item1的父元素的第一个子元素;.item:first-of-type匹配了类为.item1的父元素下各种相同标签的第一个子元素，即p和h3的第一个。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2FCSS%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式 1&lt;p style="background-color: red"&gt;&lt;/p&gt; 内部样式 123456&lt;style&gt; .demo &#123; margin: 0 auto; background-color: #ccc; &#125;&lt;/style&gt; 外部样式通过link引入外部css文件 123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/head&gt; @import引入 123&lt;style&gt; @import url(style.css);&lt;/style&gt; link和@import的区别： 引入的语法不同 link的语法为： 1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt; @import语法为: 123&lt;style type="text/css"&gt; @import url(style.css);&lt;/style&gt; link是html标签，link标签除了可以加载CSS外，还可以做很多事情，比如定义RSS，定义rel连接属性等；而@import看作是CSS的样式，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link支持使用JavaScript控制DOM去改变样式；而@import不支持。 link是html标签，无兼容性问题；@import是在CSS2.1提出的，低版本浏览器不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css 相对路径，当前文件夹内css文件夹内的a.css ./css/a.css 相对路径，同上 b.css 相对路径，当前文件夹下的b.css ../imgs/a.png 相对路径，上级目录下img文件夹下的a.png /Users/hunger/project/css/a.css 绝对路径，本地文件夹内的a.css /static/css/a.css 相对路径，在网站根目录的static文件夹下css文件夹下的a.css http://kmac007.com/8-1.png 绝对路径，指向网站上的图片 如果我想在kmac007.com上展示一个图片，需要怎么操作? 获取图片URL 打开kmac007 在body中加入img标签，URL为图片URL 修改URL为相对路径 列出5条以上html和 css 的书写规范1. CSS 文件使用无 BOM 的 UTF-8 编码。 2. 选择器 与 { 之间必须包含空格。 3. 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 4. 列表型属性值 书写在单行时，, 后必须跟一个空格。 5. 属性定义后必须以分号结尾。 6. 在可以使用缩写的情况下，尽量使用属性缩写。 7. 长度为 0 时须省略单位。 8. 表示小数时，可以省略小数点前的0]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表单的用法简介]]></title>
    <url>%2F2017%2FHTML%E8%A1%A8%E5%8D%95%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[标签用于用户输入创建HTML表单 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含 menus、textarea、fieldset和label元素。 表单用于向服务器传输数据 属性 属性 值 描述 action URL 规定当提交表单时向何处发送表单数据 autocomplete on off 规定是否启用表单的自动完成功能 method get post 规定用于发送form-data的HTTP方法 name form_name 规定表单名称 enctype application/x-www-form-urlencoded ; multipart/form-data ; text/plain 规定在发送表单数据之前如何对其进行编码。 inputtext, password, submit12345&lt;form action="form_action.php" method="get"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; checkbox1234&lt;form action="form_action.php" method="get"&gt; 汽车: &lt;input type="checkbox" name="Car"&gt; 飞机: &lt;input type="checkbox" name="Plane" checked="checked"&gt;&lt;/form&gt; radio1234&lt;form action="form_action.php" method="get"&gt; 男：&lt;input type="radio" checked="checked" name="Sex" value="male"&gt; 女: &lt;input type="radio" name="Sex" value="female"&gt;&lt;/form&gt; select12345678&lt;form&gt; &lt;select name="city"&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="guangzhou"&gt;广州&lt;/option&gt; &lt;option value="shenzhen" selected&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; textarea1&lt;textarea rows="10" cols="30"&gt; button123&lt;form&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2FHTML.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别 HTML：超文本标记语言（HyperText Markup Language）,是一种用于创建网页的标准标记语言，被涉及用来显示数据。 XML：可扩展标记语言（Extensible Markuo Language）,它被涉及用来传输和存储数据。它是对超文本标记语言的补充，是各种应用程序之间进行数据传输的常用工具。由于标签没有被预定义，使用者可以自行定义标签。 XHTML：可扩展的超文本标记语言（Extensible HyperText Markup Language）,HTML4 和XML1.0 重组而成。改进了HTML定义不规范，结构不严谨的缺点。它的语法更加严格，相对HTML的兼容性也不差。 怎样理解 HTML 语义化什么是语义化?根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化? 在没有CSS的情况下，页面也能呈现合理的结构 良好的用户体验，例如title、alt用于解释名词或解释图片信息 有利于SEO：有利于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重 用HTML开发特殊设备的网页时，有助于这些设备解析（如屏幕阅读器、盲人阅读器、移动设备等），使其能以合理的结构呈现 便于团队开发和维护，语义化更具可读性。 内容与样式分离的原则 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现内联样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 常见的meta标签 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 页面关键字 1&lt;meta name="keywords" content="your tags"&gt; 页面描述 1&lt;meta name="description" content="150 words"&gt; 声明文件编码 1&lt;meta charset="UTF-8"&gt; viewport:能优化移动浏览器显示 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 优先使用IE最新版本和Chrome 12345&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=6" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=7" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=8" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制 1&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!DOCTYPE html&gt; 的作用? 文档声明声明文档的解析类型(document.compatMode)，避免浏览器的混杂模式。 严格模式：浏览器使用W3C的标准解析渲染页面 混杂模式：浏览器使用自身的方式解析渲染页面 &lt;!DOCTYPE html&gt;的作用是声明该页面的HTML版本为HTML5如果没有&lt;!DOCTYPE html&gt;，那么compatMode默认是BackCompat，即为混杂模式，浏览器按照自己的方式解析渲染页面，那么在不同的浏览器下就会到显示不同的样式。而添加了&lt;!DOCTYPE html&gt;，浏览器就会遵循W3C标准来解析渲染页面。 浏览器乱码的原因是什么？如何解决页面的编码方式与浏览器的解码方式不匹配；解决方法为在中加1&lt;meta charset="文档编码方式"&gt; 常见浏览器及其内核 浏览器 内核 IE Trident Chrome WebKit Safari WebKit Firefox Gecko Opera Presto 其中国内的浏览器一般为WebKit/Trident的双内核，如360浏览器，QQ浏览器等 常见标签及其使用场景12345678910111213141516171819202122232425262728293031323334&lt;!--...--&gt;：注释&lt;!DOCTYPE&gt;：定义文档类型&lt;html&gt;： 定义 HTML 文档&lt;head&gt;：定义关于文档的信息&lt;body&gt;： 定义文档的主体&lt;header&gt;：定义了文档的头部区域&lt;section&gt;：&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;footer&gt;：定义 section 或 body的页脚。&lt;div&gt;： 定义文档中的节&lt;meta&gt;：定义关于 HTML 文档的元信息。&lt;title&gt;：定义文档的标题。&lt;link&gt;：定义文档与外部资源的关系&lt;script&gt;：定义客户端脚本。&lt;nav&gt;：定义导航链接的部分&lt;aside&gt;：定义页面的侧边栏内容&lt;a&gt;：定义超文本链接&lt;br&gt;： 定义换行&lt;button&gt;： 定义一个点击按钮&lt;canvas&gt;：定义图形,绘图&lt;form&gt;：定义了HTML文档的表单&lt;h1&gt; to &lt;h6&gt;：定义 HTML 标题&lt;iframe&gt;：定义内联框架&lt;img&gt;：定义图像&lt;input&gt;：定义输入控件&lt;label&gt;：定义 input 元素的标注&lt;li&gt;：定义列表的项目&lt;object&gt;：定义内嵌对象&lt;param&gt;：定义对象的参数。&lt;ol&gt;： 定义有序列表。&lt;p&gt;： 定义段落。&lt;select&gt;：定义选择列表（下拉列表）。&lt;option&gt;：定义选择列表中的选项。&lt;style&gt;：定义文档的样式信息。&lt;table&gt;： 定义表格。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>语义化</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入 URL 到页面展示发生了什么事情]]></title>
    <url>%2F2017%2F%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85.html</url>
    <content type="text"><![CDATA[这是一道经典的前端面试题，在学习的过程中，我想如果通过自己的语言来描述出来印象会更加深刻。 什么是URL URL(Uniform / Universal Resource Locator)统一资源定位符，如同在网络上的门牌，是因特网上标准的资源的地址。URL的标准格式如下：协议类型://服务器地址（必要时需加上端口号）/路径/文件名 例如：http://www.jianshu.com/users/78757d5285cd/timeline协议：http网络地址：www.jianshu.com资源路径：users/78757d5285cd/timeline 流程浏览器中输入URL并回车浏览器查找域名的IP地址1. 浏览器缓存 – 浏览器会缓存DNS记录一段时间 2. 系统缓存 - 从 Hosts 文件查找是否有该域名和对应 IP。 3. 路由器缓存 – 一般路由器也会缓存域名信息。 4. ISP DNS 缓存（互联网服务提供商的DNS缓存） – 比如到电信的 DNS 上查找缓存。 5. 如果都没有找到，则向根域名服务器查找域名对应 IP，根域名服务器把请求转发到下一级，直到找到 IP 浏览器发送一个HTTP请求到web服务器服务器处理 常见的 web服务器有 Apache、Nginx、IIS、Lighttpd web服务器接收用户的Request 交给网站代码，或者接受请求反向代理到其他 web服务器网站处理URL中的文件地址部分经过服务器上的路由程序重定向到对应的控制器(controller)对象,控制器对象根据URL中指定的操作执行相关的逻辑并调用目标数据的模型(Model)对象,模型对象与数据库交互完成目标操作后,控制器将模型中反馈的数据填充到视图中。视图部分(通常是HTML页面)作为HTTP响应发送到浏览器端。浏览器处理HTML字符串被浏览器接受后被一句句读取解析解析到link 标签后重新发送请求获取css解析到 script标签后发送请求获取 js，并执行代码解析到img 标签后发送请求获取图片资源绘制网页将渲染好的页面图像显示出来，并开始响应用户的操作。 以上只是一个简单的流程，过程中还会涉及到很多问题。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
        <tag>URL</tag>
      </tags>
  </entry>
</search>
