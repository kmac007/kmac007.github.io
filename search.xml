<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery学习使用笔记]]></title>
    <url>%2F2017%2FjQuery%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[库vs框架 库: 对原生代码进行一个完整的封装，通过封装解决许多兼容性的问题。用户可以简易的调用API来构建项目，而不需要考虑许多兼容性问题。 框架：会基于自身的特点向用户提供一套完整的模版，用户需要按照框架规范来构建项目。 类比来说：前端库就像我们家里的工具箱，里面有锯子、锤子等工具，需要时，我们从工具箱中取工具；而框架像是房子的骨架，我们通过给房子添加建材等，使其完整。 jQuery的作用jQuery是JavaScript的一个类库，仍是js，jQuery主要用来简化原生js的各种操作以及解决各种浏览器之间的兼容性。jQuery能办到的事情原生js都能办到。通常来说jQuery有以下几个功能： 方便快捷获取DOM元素 动态修改页面样式、动态改变DOM内容 解决跨浏览器兼容 响应用户的交互操作 为页面添加动态效果 统一Ajax操作 简化常见的JavaScript操作 与原生DOM对象相互转换DOM对象转jQuery对象 1$(document.getElementById("btn") //通过$()将DOM对象包裹起来转换成jQuery对象 jQuery对象转DOM对象 123456&lt;ul class="ct"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 通过类数组下标方式转换成DOM对象 12$(".ct&gt;li")[0]$(".ct&gt;li").eq(0)[0] 通过get方法 1$(".ct&gt;li").get(0) 事件绑定onon()为事件绑定的首选方法 在被选元素及子元素上添加一个或多个事件处理程序语法: $(selector).on(event,childSelector,data,function,map)参数: event:必需。规定要从被选元素添加的一个或多个事件或命名空间。由空格分隔多个事件值。必须是有效的事件 data:可选。规定只能添加到指定的子元素上的事件处理程序（且不是选择器本身，比如已废弃的 delegate() 方法）。 function:可选。规定当事件发生时运行的函数。 map:规定事件映射 ({event:function, event:function, …})，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。 offoff() 方法通常用于移除通过 on() 方法添加的事件处理程序。 使用on绑定事件使用事件代理的写法：123456789101112//html&lt;ul class="ct"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(".ct").on('click', 'li', function () &#123; console.log($(this).text()) &#125;)&lt;/script&gt; 展示与隐藏元素展示元素： 1.show( duration [, easing ] [, complete ] ) 隐藏元素： 1.hide([duration ] [,easing ] [,complete ]) 没有参数时直接等同于直接设置选中元素display属性，如： 1234.css('display', 'none').toggle( [duration ] [, easing ] [, complete ] )//用来切换元素的隐藏、显示，类似toggleClass 参数： duration：动画持续的时间。一个字符串或数字决定动画运行的时间。（注：默认值为”400毫秒”） easing：表示过渡使用哪种缓冲函数，jQuery自身提供”linear”和”swing”,默认为”swing” complete：在动画完成时执行的函数 jQuery动画1.animate( properties [, duration ] [, easing ] [, complete ] ) properties是一个CSS属性和值的对象,动画将根据这组对象移动。 如： 123456789$('#clickme').click(function() &#123; $('#book').animate(&#123; opacity: 0.25, left: '+=50', height: 'toggle' &#125;, 5000, function() &#123; // Animation complete. &#125;);&#125;); .animate( properties, options ) options是一组包含动画选项的值的集合。 常用的选项: duration (default: 400)：一个字符串或者数字决定动画将运行多久。默认值: “normal”， 三种预定速度的字符串(“slow”, “normal”, 或 “fast”或表示动画时长的毫秒数值(如：1000) ） easing (default: swing)：一个字符串，表示过渡使用哪种缓动函数。jQuery自身提供”linear” 和 “swing”，其他效果可以使用jQuery Easing Plugin插件 step：每个动画元素的每个动画属性将调用的函数。这个函数为修改Tween 对象提供了一个机会来改变设置中得属性值。 complete：在动画完成时执行的函数]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的几种解决方案]]></title>
    <url>%2F2017%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[同源策略浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。所谓的同源策略指的是三个相同： 协议相同 域名相同 端口相同 例如: https://www.kmac007.com/2017/index.html 这个网址，协议是https，域名是kmac007.com，端口是80（默认端口可以省略）对于如下网址： http://www.kmac007.com/2017/index.html 不同源(协议不同) https://www.kmac007.com/2017/first.html 同源 https://kmac007.com/2017/first.html 不同源（域名不同） https://kmac007.com:8080/2017/first.html 不同源（端口不同） 同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 跨域以及跨域的几种实现方式跨域指的是，突破同源策略，不同源之间进行数据传输或通信。 跨域有如下几种实现方式： JSONP CORS：跨域资源共享（Cross-origin resource sharing） document.domain window.postMessage等 JSONP在JS中我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。由于script标签不受同源策略的限制，可以通过script标签向服务器请求数据。而JSONP就是通过这个特性来实现的。 JSONP的原理是，在网页中动态添加一个script标签，src指向接口地址，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据包裹在一个指定名字的回调函数里传回来。 如: script标签的src指向 ‘kmac007.com/getData?callback=jsonp’,以jsonp(data)形式的返回数据，调用页面上的jsonp函数从而获取到了data 实现示例1234567891011121314//前端部分: function addScriptTag(src) &#123; var script = document.createElement('script'); script.src = src; document.body.appendChild(script); &#125; window.onload = function () &#123; addScriptTag('http://kmac007.com/getData?callback=jsonp'); &#125; function jsonp(data) &#123; console.log(data.name) &#125; 服务器收到这个请求后，会将数据放在回调函数的参数位置返回：12345678910111213141516//后端部分：app.get('/getData', function (req, res) &#123; var data = &#123; "name": "dk", "age": "23" &#125; var cb = req.query.callback if (cb) &#123; res.send(cb + '(' + JSON.stringify(data) + ')') &#125; else &#123; res.send(data) &#125;&#125;)/* 返回：json(&#123;"name":"dk","age":"23"&#125;)*/ 优点 很好的解决了跨域通信的问题，用户传递一个callback参数给服务器，服务器根据callback返回特定的callback包裹的数据，客户端可以随意定制自己的的函数处理返回的数据。 兼容性非常好，在非常古老的浏览器上也能很好的实现 缺点 JSONP只支持get请求而不支持其他HTTP请求，参数的形式只能做url拼接，后台取值会比较繁琐 存在安全隐患，动态插入&lt;script&gt;标签其实就是一种脚本注入。 document.domainCookie是服务器写入浏览器的一小段消息，只有同源的网页才能共享。但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享Cookie。 举例来说, A网页是http://www1.kmac007.com/a.html，B网页是html://www2.kmac007.com/b.html，只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = 'kmac007.com' 现在A网页中设置一个Cookie 1document.cookie = "test=1" 网页B中就可以读取这个Cookie 1var allCookie = document.cookie window.postMessage由HTML5引入的API,postMEssage()方法允许来自不同源的脚本采用异步方式进行有限通信。这个API为 window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 postMessage方法的第一个参数是具体的信息内容，第二个参数是接收信息的窗口源（origin）,即“协议+域名+端口”。也可以设为*，表示不限制域名，向所有窗口发送。 即父窗口与子窗口互相发送消息，通过message事件，监听对方的消息，实现跨域。 父窗口：123456789101112131415$('.main input').addEventListener('input', function () &#123; console.log(this.value); window.frames[0].postMessage(this.value, '*'); //向子窗口发送信息&#125;)window.addEventListener('message', function (e) &#123; $('.main input').value = e.data console.log(e.data); //监听子窗口发送信息的变化&#125;);function $(id) &#123; return document.querySelector(id);&#125; 子窗口：1234567891011121314$('#input').addEventListener('input', function()&#123; window.parent.postMessage(this.value, '*'); //向父窗口发送信息&#125;)window.addEventListener('message',function(e) &#123; $('#input').value = e.data console.log(e.data); //监听父窗口的发送的信息变化&#125;);function $(id)&#123; return document.querySelector(id);&#125; CORSCORS是一个W3C标准，全称是“跨域资源共享”(Cross-origin resource sharing)。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。 实现功能非常简单，只需要由服务器发送一个响应标头即可。它是通过客户端+服务端协作声明的方式来确保请求安全的。服务端会在HTTP请求头增加一系列HTTP请求参数（例如Acess-Control-Allow-Origin等），来限制哪些域的请求和哪些类型可以接受，而客户端在发起请求时必须声明自己的源(Origin)，否则服务器将不予处理，如果客户端不作声明，请求甚至会被浏览器直接拦截到不了服务端。服务端收到HTTP请求后会进行域的比较，只有同域的请求才会处理。 浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要满足以下两大条件，就属于简单请求：12345678910（1）请求方法是以下三种方法之一：- HEAD- GET- POST（2）HTTP的头信息不超过以下几种字段：- Accept- Accept-Language- Content-Language- Last-Event-ID- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理方式是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说就是在头信息中，增加一个Origin字段。而Origin字段说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，浏览器会返回一个正常的HTTP回应。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息 。如： 1234Access-Control-Allow-Origin: http://api.kmac007.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: showMesContent-Type: text/html; charset=utf-8 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求。浏览器先询问服务器，当前网页所在的域名是否在服务器的虚空名单之中，一次可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就会报错。 实现实例:12345678910111213141516171819//前端部分&lt;body&gt; &lt;button id="btn"&gt;点我&lt;/button&gt; &lt;script&gt; var btn = document.getElementById("btn") btn.addEventListener('click', function () &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var newLi = document.createElement('li') newLi.innerText = xhr.responseText document.body.appendChild(newLi) &#125; &#125; xhr.open('get', 'http://b.kmac007.com:8080/getData', true) xhr.send() &#125;) &lt;/script&gt;&lt;/body&gt; 1234567//后端部分app.get('/getData',function(req,res)&#123; var data = "are u ok" res.header("Access-Control-Allow-Origin","*") // 加入响应头Access-Control-Allow-Origin res.send(data)&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2FAjax.html</url>
    <content type="text"><![CDATA[Ajax是什么?有何作用 AJax为“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。 作用是：无需重新加载页面即可与服务器交换数据。 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。这种技术带来了不错的用户体验。 而传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 用JS发起请求的几个步骤1. 创建一个XMLHttpRequest对象()1var xhr = new XMLHttpRequest() 2. 监听请求成功后的变化1234567xhr.onreadystatechange = function() &#123; if (this.readyState== 4)&#123; if (xhr.status === 200 || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; &#125;&#125; xhr.responseText即服务器返回的内容（默认为字符串） 3. 设置请求参数1xhr.open("GET", "url", true) 4. 发送请求1xhr.send() 在jQuery.ajax中对以上进行了封装123$.get('url').then(function(response)&#123; //response即为响应内容&#125;) 点击按钮，使用 ajax 获取数据，防止重复点击可以使用状态锁，判断数据是否到来。状态锁初始值为true，当发起一次请求后状态锁值变为false，此时，若是未获得响应的情况下重复点击，函数均被返回，等到状态码变为4即数据接收完毕，状态锁值变为true。12345678910111213141516171819var isDataArrive = true //默认为truevar btn = document.getElementById("getData")btn.addEventListener('click', function () &#123; if (!isDataArrive) &#123; //如果数据没有到来 return &#125; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; isDataArrive = true // 收到响应 &#125; &#125; xhr.open() xhr.send() isDataArrive = false //停止再次发送请求&#125;) 简单封装一个 ajax 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//封装function ajax(opts) &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var results = JSON.parse(xhr.responseText) opts.success(results) &#125; if(xhr.status === 404)&#123; opts.error() &#125; &#125; &#125; var dataString = '' for (var key in opts.data) &#123; dataString += key + "=" + opts.data[key] + "&amp;" &#125; dataString = dataString.substr(0, dataString.length - 1) if (opts.type.toLowerCase() === "get") &#123; xhr.open("get", opts.url + "?" + dataString, true) xhr.send() &#125; if (opts.type.toLowerCase() === "post") &#123; xhr.open("post", opts.url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded") xhr.send(dataString) &#125;&#125;//调用document.querySelector('#btn').addEventListener('click', function() &#123; ajax(&#123; url: '/login', //接口地址 type: 'get', // 类型， post 或者 get, data: &#123; username: 'kmac007', password: 'kmac007' &#125;, success: function(ret) &#123; console.log(ret); // &#123;status: 0&#125; &#125;, error: function() &#123; console.log('出错了') &#125; &#125;)&#125;); 实现加载更多的功能，后端在本地使用server-mock来模拟数据前端部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;加载更多&lt;/title&gt; &lt;style&gt; ul, li &#123; margin: 0; padding: 0; &#125; #ct li &#123; width: 100%; list-style: none; padding: 10px; margin-top: 10px; cursor: pointer; border: 1px solid #ccc; &#125; #ct li:hover &#123; background-color: green; color: #fff; &#125; #btn &#123; border-radius: 5px; text-align: center; width: 80px; padding: 10px; margin: 10px auto; border: 1px solid palevioletred; color: palevioletred; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ct"&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;/ul&gt; &lt;div id="btn"&gt; 加载更多 &lt;/div&gt; &lt;script&gt; var btn = document.getElementById("btn") var ct = document.getElementById("ct") var pageIdx = 2 var isDataArrive = true btn.addEventListener('click', function (e) &#123; e.preventDefault() if (!isDataArrive) &#123; return &#125; isDataArrive = false ajax(&#123; url: '/loadMore', //接口地址 type: 'get', data: &#123; index: pageIdx, length: 6 &#125;, success: function (results) &#123; renderPage(results) &#125;, error: function () &#123; console.log("error") &#125; &#125;) &#125;) function renderPage(news) &#123; var fragment = document.createDocumentFragment() for (var i = 0; i &lt; news.length; i++) &#123; var node = document.createElement("li") node.innerText = news[i] fragment.appendChild(node) &#125; ct.appendChild(fragment) &#125; function ajax(opts) &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; var results = JSON.parse(xhr.responseText) opts.success(results) pageIdx += 6 &#125; else &#123; opts.error() &#125; isDataArrive = true &#125; &#125; var dataStr = '' for (var key in opts.data) &#123; dataStr += key + "=" + opts.data[key] + "&amp;" &#125; dataStr = dataStr.substr(0, dataStr.length - 1) if (opts.type.toLowerCase() === "get") &#123; xhr.open("get", opts.url + "?" + dataStr, true) xhr.send() &#125; if (opts.type.toLowerCase() === "post") &#123; xhr.open("post", opts.url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded") xhr.send(dataStr) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端部分，采用server-mock12345678910//加载更多router.get('/loadMore', function (req, res) &#123; var curIdx = req.query.index var len = req.query.length var data = [] for (var i = 0; i &lt; len; i++) &#123; data.push('内容' + (parseInt(curIdx) + i)) &#125; res.send(data)&#125;) 前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？前后端开发联调需要注意的事情： 约定数据：需要传输的数据及其数据类型 约定接口：确定接口名称及请求响应的格式，请求的参数名称、响应的数据格式 根据这些约定整理成接口文档 如何mock数据：参照接口文档，使用假数据来验证接口和页面响应的正确性。 如果有线上接口，可以根据线上接口来测试 可以使用mock工具来mock数据。 也可以通过node express搭建本地服务器，写脚本提供临时数据。 也可以直接将mock数据写入代码中，但缺点是联调需要做的改动较多，接口文档变化需要手动刷新。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包、定时器与BOM]]></title>
    <url>%2F2017%2F%E9%97%AD%E5%8C%85%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8EBOM.html</url>
    <content type="text"><![CDATA[什么是闭包JavaScript变量作用域有两种，分别是全局的作用域和函数作用域，JavaScript函数的局部变量可以直接读取全局变量。而函数外部变量并不能读取函数内的局部变量，但是通过闭包，可以在函数外部访问到内部的变量。 JavaScript作用域链：子对象会一级一级的向上查找父对象的变量，父对象的所有变量对子对象都是可见的，反之则不成立。 123456789function foo(x) &#123; var local = 1 return function() &#123; console.log(x + local) &#125;&#125;var bar = foo(2)bar() 如上，1234var local = 1return function() &#123; console.log(x + local)&#125; 这就是一个闭包 即闭包指的是函数和函数内部能访问到的变量的总和。 闭包的作用： 暴露一个可以访问局部变量的函数 隐藏一个变量，不让其他人直接访问这个变量 闭包的应用场景写一个函数判断是否首次加载 123456789101112131415161718//判断是否首次加载function firstLoad() &#123; //声明一个_list，外部无法直接访问与修改_list var _arr = [] return function(id) &#123; if (_arr.indexOf(id) &gt;= 0) &#123; return false &#125; else &#123; _arr.push(id) return true &#125; &#125;&#125;var isFirstLoad = firstLoad()isFirstLoad(10)isFirstLoad(10) 修改代码让fnArr[i]() 输出 i。使用两种以上的方法1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log( fnArr[3]() ); // 输出10 代码的输出结果为1012345678910// 方法一var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; !function(i)&#123; fnArr[i]=function()&#123; return i; &#125; &#125;(i)&#125;console.log(fnArr[3]()); // 12345678910// 方法二var fnArr = [];for (var i = 0; i &lt; 10; i++) &#123; fnArr[i] = (function(i)&#123; return function()&#123; return i; &#125; &#125;(i));&#125;console.log(fnArr[3]()); // 12345678// 方法三var fnArr = [];for (let i = 0; i &lt; 10; i++) &#123; //使用ES6的let语法 fnArr[i] = function () &#123; return i; &#125;;&#125;console.log(fnArr[3]()); // 封装一个汽车对象，可以通过如下方式获取汽车状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var Car = (function () &#123; var speed = 0 function setSpeed(s) &#123; speed = s &#125; function getSpeed() &#123; console.log(speed) &#125; function accelerate() &#123; speed += 10 &#125; function decelerate() &#123; speed &gt; 0 ? speed -= 10 : speed &#125; function getStatus() &#123; if (speed &lt;= 0) &#123; console.log("stop"); speed = null &#125; else if (speed &gt; 0) &#123; console.log("running") &#125; &#125; return &#123; setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate();Car.decelerate();Car.getStatus(); //'stop';//Car.speed; //error 下面这段代码输出结果是? 为什么?123456789var a = 1;var a ;setTimeout(function()&#123; a = 2; console.log(a); //2&#125;, 0);console.log(a); //1a = 3;console.log(a); //3 输出结果为1,3,2 因为setTimeout()会在程序的最后执行，前面声明a并赋值，重复声明不会改变a的值, setTimeOut异步 下面这段代码输出结果是? 为什么?123456var flag = true;setTimeout(function()&#123; flag = false;&#125;,0) //原本会在程序的末尾执行，但由于while是个死循环，程序不会往下执行，故setTimeout也不会执行while(flag)&#123;&#125; //flag永远是true,死循环console.log(flag); //不会执行 下面这段代码输出？如何输出delayer: 0, delayer:1...（使用闭包来实现）1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log('delayer:' + i); &#125;, 0); console.log(i);&#125;// 输出 0,1,2,3,4 delayer: 5, delayer: 5... 修改：123456789for (var i = 0; i &lt; 5; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log('delayer:' + i); &#125;, 0); console.log(i); &#125;)(i)&#125;// 输出0,1,2,3,4 delayer: 0, delayer: 1, delayer: 2, delayer: 3, delayer: 4, 如何获取元素的真实宽高使用window.getComputedStyle()方法123var ele = doutment.getElementById(&quot;test&quot;)window.getComputedStyle(ele).width //获取id为test元素的宽window.getComputedStyle(ele).height //获取id为test元素的高 URL如何编码解码？为什么要编码？JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent()区别 encodeURI方法不会对下列字符编码 ASCII字母 数字 ~!@#$&amp;*()=:/,;?+’ encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()’ 所以encodeURIComponent比encodeURI编码的范围更大。之所以要进行编码，是因为URL中有些字符会引起歧义。 补全如下函数，判断用户的浏览器类型123456789101112131415function isAndroid() &#123; return /Android/.test(window.navigator.userAgent)&#125;function isIphone() &#123; return /iPhone/.test(window.navigator.userAgent)&#125;function isIpad() &#123; return /iPad/.test(window.navigator.userAgent)&#125;function isIOS() &#123; return /iOS/i.test(window.navigator.userAgent)&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>BOM</tag>
        <tag>闭包</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2017%2FDOM%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[DOM0级事件和DOM2级事件 DOM0级事件处理程序是将一个函数赋值给一个事件处理程序属性。每个元素（包括window 和document）都有自己的事件处理程序属性，这些属性通常全部小写，如：onclick；同属性多次赋值的话，后面的属性会覆盖前面的属性。删除事件处理程序只需要将属性值设置为null即可，具有跨浏览器优势。这种方式添加的事件处理程序会在事件流的冒泡阶段处理。 DOM2级事件处理程序，定义了两个方法，用于处理指定和删除事件处理程序：addEventListener(), removeEventListener()。都接受3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值（默认为false）。最后一个布尔参数如果是true，表示在捕获阶段调用处理程序，而false表示在冒泡阶段调用事件处理程序。可以添加多个事件处理程序。但IE8及更早的版本不支持。 attachEvent与addEventListener的区别？区别如下： attachEvent()接受两个参数：事件处理程序名称与事件处理程序函数；而 addEventListener()接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（默认值为false可忽略）。 事件处理程序的执行顺序不同：通过attachEvent()给某元素添加多个对于同一事件的处理程序时，它们的执行顺序是按照最后添加的先执行。 对于addEventListener()的事件处理程序则是按照添加顺序执行。 由于IE8及更早版本只支持事件冒泡，所用通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段，而addEventListener()可以通过第三个参数布尔值来确定处理程序是在捕获阶段还是冒泡阶段调用。 作用域: 使用attachEvent()，事件处理程序会在全局作用域中运行，因此this等于window; 而addEventListener()的作用域是元素本身，this是指的是触发元素。 第一个参数不同：attachEvent()第一个参数为”on”+事件名，而addEventListener()的第一个参数为事件名。 IE事件冒泡与DOM2事件IE事件冒泡 对于IE事件冒泡：即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。如图，如果单击了页面中的元素，那么click事件就会按照图中1、2、3、4的顺序传播。 DOM事件流 对于DOM事件流：“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。当点击元素时，会按照如上图所示的顺序触发事件。 阻止事件冒泡与阻止默认事件 标准浏览器 阻止冒泡: e.stopPropagation() 阻止默认事件：e.preventDefault() IE浏览器 阻止冒泡：event.cancelBubble = true 阻止默认事件：event.returnValue = false 有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容12345678&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;kmac007&lt;/li&gt; &lt;li&gt;小站&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//todo ...&lt;/script&gt; 代码如下： 1234var myLi = document.querySelector(".ct");myLi.addEventListener("click", function (event) &#123; console.log(event.target.innerText);&#125;); 补全代码，要求： 当点击按钮开头添加时在这里是元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串. 当点击每一个元素li时控制台展示该元素的文本内容。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;kmac007&lt;/li&gt; &lt;li&gt;小站&lt;/li&gt;&lt;/ul&gt;&lt;input class="ipt-add-content" placeholder="添加内容" /&gt;&lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt;&lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt;&lt;script&gt; //你的代码 function $(id) &#123; return document.querySelector(id) &#125; var ct = $(".ct") var btnStart = $("#btn-add-start") var btnEnd = $("#btn-add-end") var iptContent = $(".ipt-add-content") ct.addEventListener('click', function (e) &#123; console.log(e.target.innerText) &#125;) btnStart.addEventListener('click', function () &#123; if (!iptContent.value) &#123; alert("请输入内容") return false &#125; else &#123; var newLi = document.createElement("li") newLi.innerText = iptContent.value ct.insertBefore(newLi, ct.childNodes[0]) &#125; &#125;) btnEnd.addEventListener('click', function () &#123; if (!iptContent.value) &#123; alert("请输入内容") return false &#125; else &#123; var newLi = document.createElement("li") newLi.innerText = iptContent.value ct.appendChild(newLi) &#125; &#125;)&lt;/script&gt; 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。12345678910111213141516171819202122232425262728&lt;ul class="ct"&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/Mourinho.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/ibr.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="https://kmac007.github.io/demos/test/manutd/img/rooney.png"&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class="img-preview"&gt;&lt;/div&gt;&lt;script&gt; //你的代码 function $(id) &#123; return document.querySelector(id) &#125; var ct = $(".ct") var pre = $(".img-preview") //鼠标移入事件 ct.addEventListener("mouseover", function (e) &#123; if (e.target.nodeName.toLowerCase() === "li") &#123; var img = document.createElement("img") img.src = e.target.getAttribute("data-img") pre.appendChild(img) &#125; &#125;) //鼠标移出事件 ct.addEventListener("mouseout", function (e) &#123; if (e.target.nodeName.toLowerCase() === "li") &#123; pre.innerHTML = '' &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>DOM</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作]]></title>
    <url>%2F2017%2FDOM%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[DOM对象的innerText和innerHTML有什么区别？ innerText返回元素内所包含的文本内容，在多层次的时候会按照元素的深浅顺序拼接其内容 innerHTML返回的是元素的HTML结构 elem.children和elem.childNodes的区别elem.children与elem.childNodes 两者都是返回子节点；前者返回的是节点集合后者返回指定节点的子节点的节点集合包括元素、文本、注释等 查询元素有几种常见的方法？ES5的元素选择方法是什么?1234567891011常见的方法有：1、getElementById()2、getElementsByTagName()3、getElementsByClassName()4、getElementsByName()ES5的元素选择方法是：1. querySelector()2. querySelectorAll() 如何创建一个元素？如何给元素设置属性？如何删除属性123var s = document.createElement("span") //创建元素s.setAttribute("name","DK") // 设置属性s.removeAttribute("name") //删除属性 如何给页面元素添加子元素？如何删除页面元素下的子元素?12element.appendChild() //给element添加子元素element.removeChild(child) //删除element元素下的子元素child element.classList有哪些方法？如何判断一个元素的 class 列表中是包含某个 class？如何添加一个class？如何删除一个class?12345add(class1, class2, ...) //在元素中添加一个或多个类名，如指定的类名已存在，则不会添加contains(class) //返回布尔值，判断指定的类名是否存在item(index) //返回类名在元素中的索引remove(class1, class2, ...) //移除元素中的一个或多个类名，移除不存在的类名不会报错toggle(class, true|false) //在元素中切换类名，第一个参数为要在元素中移除的类名，并返回false。如果类名不存在则会在元素中添加类名，并返回true。第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管类名是否存在。 利用contains()判断是否包含某个class,用add()和remove()添加和删除class 如何选中如下代码所有的li元素？ 如何选中btn元素？12345678&lt;div class="mod-tabs"&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class="btn"&gt;点我&lt;/button&gt;&lt;/div&gt; 选中所有的li:12document.getElementsByTagName('li')document.querySelectorAll('li') 选中btn元素:1234document.getElementsByTagName("button")[0]document.getElementsByClassName("btn")[0]document.querySelector(".btn")doucument.querySelectorAll(".btn")[0]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型及对象拷贝]]></title>
    <url>%2F2017%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D.html</url>
    <content type="text"><![CDATA[引用类型与非引用类型非引用类型：Undefined, Null, Number, String, Boolean 引用类型有: Function, Object, Array, Date, RegExp 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //false 这里是判断obj1与obj2是否指向相同的对象console.log(obj1 = obj2); //&#123;a:1, b:2&#125; 使obj1的指针指向obj2console.log(obj1 == obj2); //true 由于obj1, obj2指向相同的对象，所以为true 如下代码输出什么? 为什么12345678910111213141516171819var a = 1var b = 2var c = &#123; name: 'dk', age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = 'hello'd[2]['age'] = 3console.log(aa) //1, 将a的值赋予aaconsole.log(bb) //2, 将b的值赋予bbconsole.log(cc) //&#123; name: 'hello', age: 3 &#125;, cc与c指向同一个对象,改变c与会使cc改变console.log(dd) // [1, 2, &#123; name: 'hello', age: 3 &#125;], dd与d指向同一个对象,改变d同样会使dd改变 如下代码输出什么? 为什么123456789101112131415var a = 1var c = &#123; name: 'dk', age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a)f2(c)f1(c.age)console.log(a) //1, 因为f1是按值传递，仅是将值传递进去，不会改变全局变量aconsole.log(c) //&#123; name: 'dk', age: 3 &#125;, f2(c)是引用传递，变量指针指向obj, 会改变c中的值，而f1(c.age)为值传递，同理不会改变c 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt;= 0) &#123; arr.splice(i, 1); filter(arr); &#125; &#125;&#125;filter(arr)console.log(arr) // [3,1,2] 过滤如下数组，只保留正数，原数组不变，生成新数组12345678910111213var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = [] for(var i in arr) &#123; if(arr[i] &gt; 0) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] 对象深拷贝的几种方式 注意，ES6中Object.assign为浅拷贝 12345678910111213141516171819202122232425262728293031var obj = &#123; name: "robert", age: 3, child: &#123; name: "bob", age: 3 &#125;&#125;/*方法一*/function deepCopy1(obj) &#123; var newObj = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] !== 'object') &#123; newObj[key] = obj[key] &#125; else &#123; newObj[key] = deepCopy1(obj[key]) &#125; &#125; &#125; return newObj&#125;var obj2 = deepCopy1(obj)console.log(obj2)/*方法二*/function deepCopy2(obj) &#123; var newObj = JSON.parse(JSON.stringify(obj)) return newObj&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>引用类型</tag>
        <tag>对象拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[正则表达式常用字符及其含义 字符 含义 \d 数字字符 \w 单词字符，字母、数字下划线 \s 空白符 [a-zA-Z0-9]] 任意字母a-z,A-Z和数字 \b 单词边界 . 除了回车符和换行符之外的所有字符 * 出现零次或多次（任意次） + 出现一次或多次（至少出现一次） ? 出现零次或一次（最多出现一次） x{3} x出现3次 ^ 以XXX开头 $ 以XXX结尾 写一个函数trim(str)，去除字符串两边的空白字符123function trim(str)&#123; return str.replace(/^\s+|\s+$/g,'')&#125; 写一个函数isEmail(str)，判断用户输入的是不是邮箱1234function isEmail(str) &#123; var reg = /^\w+@\w+\.\w+$/ return reg.test(str)&#125; 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号1234function isPhoneNum(str) &#123; var reg = /^1[35789]\d&#123;9&#125;$/ return reg.test(str)&#125; 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）1234function isValidUsername(str)&#123; var reg = /^\w&#123;6,20&#125;$/ return reg.test(str)&#125; 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，只包括大写字母、小写字母、数字、下划线，且至少至少包括两种）12345678910111213141516function isValidPassword(str)&#123; if(str.length&lt;6||str.length&gt;20||/[\W]/.test(str)) &#123; return false &#125;else &#123; var count = 0 if(/[a-z]/.test(str)) count++ if(/[A-Z]/.test(str)) count++ if(/[0-9]/.test(str)) count++ if(/[_]/.test(str)) count++ if(count&gt;=2)&#123; return true &#125;else&#123; return false &#125; &#125;&#125; 写一个正则表达式，得到如下字符串里所有的颜色123var reg = /#[a-fA-F0-9]&#123;6&#125;/gvar subj = "color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee "console.log( subj.match(reg) ) // ['#121212', '#AA00ef'] 下面代码输出什么? 为什么? 改写代码，让其输出[“”hunger””, “”world””].12345678var str = 'hello "hunger" , hello "world"';var pat = /".*"/g;str.match(pat);//[""hunger" , hello "world""]//原因是贪婪模式，量词在默认下尽可能多的匹配//修改如下：var str = 'hello "hunger" , hello "world"';var pat = /".*?"/g;str.match(pat);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math数组及Date相关操作]]></title>
    <url>%2F2017%2FMath%E6%95%B0%E7%BB%84%E5%8F%8ADate%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[Math写一个函数，返回从min到max之间的随机整数，包括min不包括max123function getRandom(min, max) &#123; return Math.floor(min + Math.random() * (max - min))&#125; 写一个函数，返回从min都max之间的 随机整数，包括min包括max123function getRandom(min, max) &#123; return Math.floor(min + Math.random() * (max - min + 1))&#125; 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。12345678910111213var oldStr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"function getRandStr(len) &#123; //补全函数 var strArr = oldStr.split('') var randStr = '' for (var i = 0; i &lt; len; i++) &#123; var strKey = Math.floor(Math.random() * oldStr.length) randStr += strArr[strKey] &#125; return randStr&#125;var str = getRandStr(10); // 0a3iJiRZap 写一个函数，生成一个随机 IP 地址，一个合法的 IP 地址为 0.0.0.0~255.255.255.255123456789function getRandIp() &#123; var ipArr = [] var len = 4 for (var i = 0; i &lt; len; i++) &#123; ipArr[i] = Math.floor(Math.random() * (255 + 1)) &#125; return ipArr.join('.') &#125; getRandIp() 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff1234567891011function getRandColor() &#123; var str = "ABCDEF0123456789" var colorArr = str.split('') var len = 6 var colorStr = '' for (var i = 0; i &lt; len; i++) &#123; colorStr += colorArr[Math.floor(Math.random() * (colorArr.length))] &#125; return '#' + colorStr&#125;getRandColor() 数组数组方法里push、pop、shift、unshift、join、splice分别是什么作用？用 splice函数分别实现push、pop、shift、unshift方法push: 向数组的末尾添加一个或更多元素，并返回新的数组长度。 pop: 删除并返回数组的最后一个元素 shift: 删除并返回数组的第一个元素 unshift: 向数组的开头添加一个或更多元素，并返回新的长度。 join: 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 splice: 删除元素，并向数组添加新元素。 用splice实现push:1arr.splice(arr.length,0,item) 用splice实现pop:1arr.splice(arr.length-1,1) 用slice实现unshift:1arr.splice(0,0,item) 用slice实现shift:1arr.splice(0,1) 写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作123456789function squareArr(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] * arr[i] &#125; return arr&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] 写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变12345678910111213function filterPositive(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (typeof arr[i] === "number" &amp;&amp; arr[i] &gt; 0) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;var arr = [3, -1, 2, 'hello', true]var newArr = filterPositive(arr)console.log(newArr) //[3, 2]console.log(arr) //[3, -1, 2, 'hello', true] Date写一个函数getChIntv，获取从当前时间到指定日期的间隔时间1234567891011121314var timeStr = getChIntv("2017-05-01");function getChIntv(timeStr) &#123; var targetTime = new Date(timeStr).getTime() - 1000 * 60 * 60 * 8 var currentTime = Date.now() var offsetTime = targetTime - currentTime var days = parseInt(offsetTime / (1000 * 60 * 60 * 24)) var hours = parseInt(offsetTime % (1000 * 60 * 60 * 24) / (1000 * 60 * 60)) var mins = parseInt(offsetTime % (1000 * 60 * 60 * 24) % (1000 * 60 * 60) / (1000 * 60)) var seconds = parseInt(offsetTime % (1000 * 60 * 60 * 24) % (1000 * 60 * 60) % (1000 * 60) / 1000) return "距五一还有:" + days + "天" + hours + "小时" + mins + "分" + seconds + "秒"&#125;console.log(timeStr); // 距五一还有:11天7小时26分28秒 把hh-mm-dd格式数字日期改成中文日期1234567891011121314var str = getChsDate('2015-01-08');function getChsDate(timeStr) &#123; var dist = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二", "十三", "十四", "十五", "十六", "十七", "十八", "十九", "二十", "二十一", "二十二", "二十三", "二十四", "二十五", "二十六", "二十七", "二十八", "二十九", "三十", "三十一"]; var arr = timeStr.split('-') var year = arr[0] var month = arr[1] var day = arr[2] var chYear = dist[parseInt(year[0])] + dist[parseInt(year[1])] + dist[parseInt(year[2])] + dist[parseInt(year[3])] var chMonth = dist[parseInt(month)] var chDay = dist[parseInt(day)] return chYear + "年" + chMonth + "月" + chDay + "日"&#125;console.log(str); // 二零一五年一月八日 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串:12345678910111213141516171819function friendlyDate(time) &#123; var now = Date.now() var offsetTime = (now - time) / 1000 / 60 if (offsetTime &lt; 1) &#123; return parseInt(offsetTime * 60) + "刚刚" &#125; else if (offsetTime &gt;= 1 &amp;&amp; offsetTime &lt; 60) &#123; return parseInt(offsetTime) + "分钟前" &#125; else if (offsetTime &gt;= 60 &amp;&amp; offsetTime &lt; 60 * 24) &#123; return parseInt(offsetTime / 60) + "小时前" &#125; else if (offsetTime &gt;= 60 * 24 &amp;&amp; offsetTime &lt; 60 * 24 * 30) &#123; return parseInt(offsetTime / 60 / 24) + "天前" &#125; else if (offsetTime &gt;= 60 * 24 * 30 &amp;&amp; offsetTime &lt; 60 * 24 * 39 * 12) &#123; return parseInt(offsetTime / 60 / 24 / 30) + "月前" &#125; else if (offsetTime &gt;= 60 * 24 * 39 * 12) &#123; return parseInt(offsetTime / 60 / 24 / 30 / 12) + "年前" &#125;&#125;var str = friendlyDate('1492593606284') // 1分钟前var str2 = friendlyDate('1422583606284') //2年前]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>Math</tag>
        <tag>Date</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串与JSON相关操作]]></title>
    <url>%2F2017%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EJSON%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[使用数组拼接出如下字符串1&quot;&lt;dl class=&quot;product&quot;&gt;&lt;dt&gt;女装&lt;/dt&gt;&lt;dd&gt;短款&lt;/dd&gt;&lt;dd&gt;冬季&lt;/dd&gt;&lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt;&quot; 12345678910111213141516var prod = &#123; name: '女装', styles: ['短款', '冬季', '春装']&#125;function getTplStr(data) &#123; var arr = [] arr.push('&lt;dl class="product"&gt;') arr.push('&lt;dt&gt;' + data.name + '&lt;/dt&gt;') for (key in data['styles']) &#123; arr.push('&lt;dd&gt;' + data['styles'][key] + '&lt;/dd&gt;') &#125; arr.push("&lt;/dl&gt;") return arr.join('')&#125;var result = getTplStr(prod) //result拼接后的字符串 写出两种以上声明多行字符串的方法12345678910111213141516171819202122232425262728293031/*使用\n转义字符回车*/var str1 = "line1\nline2\nline3\n"console.log(str1)/*使用反斜杠转义*/var str2 = "line1\ line2\ line3\"console.log(str2)/*连接运算符(+)*/var str3 = "line1" + "line2" + "line3"console.log(str3)/*使用多行注释，生成多行字符串*/var str4 = (function()&#123;/* line1 line2 line3*/&#125;).toString().split('\n').slice(1,-1).join('\n')/*使用ES6的字符串扩展*/var str5 = ` line1 line2 line3`console.log(str5) 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是12345678910function isPalindrome(str) &#123; if (typeof str === "string") &#123; var newStr = str.toLowerCase().split('').reverse().join('') if(newStr === str.toLowerCase()) &#123; console.log("是回文") &#125;else &#123; console.log("不是回文") &#125; &#125;&#125; 写一个函数，统计字符串里出现出现频率最多的字符1234567891011121314151617181920function isMost(str) &#123; var dict = &#123;&#125; for (var i = 0; i &lt; str.length; i++) &#123; if(dict[str[i]]) &#123; ++dict[str[i]] &#125;else&#123; dict[str[i]] = 1 &#125; &#125; var count = 0 var maxValue for(var key in dict)&#123; if(dict[key] &gt; count)&#123; maxValue = key count = dict[key] &#125; &#125; //如果出现次数最多的字符不止一个，则加多一层循环 return maxValue + ":" + count&#125; 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如12camelize("background-color") == 'backgroundColor'camelize("list-style-image") == 'listStyleImage' 代码如下:12345678function camelize(str) &#123; var arr = str.toLowerCase().split('-') var newStr = arr[0] for (var i = 1; i &lt; arr.length; i++) &#123; newStr += (arr[i].charAt(0).toUpperCase() + arr[i].substring(1)) &#125; return newStr&#125; 写一个 ucFirst函数，返回第一个字母为大写的字符1ucFirst(&quot;hunger&quot;) == &quot;Hunger&quot; 代码如下：123function ucFirst(str) &#123; return str.charAt(0).toUpperCase() + str.substring(1)&#125; 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如12truncate("hello, my name is kmac007", 10) == "hello, thi...";truncate("hello world", 20) == "hello world" 代码如下:1234567function truncate(str, maxlength) &#123; if (str.length &gt; maxlength) &#123; return str.substring(0, maxlength) + "..." &#125; else &#123; return str &#125;&#125; JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集.JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 严格的JavaScript对象表示法表示结构化的数据。具体写法是：数据在名称/值对中；数据由逗号分隔；花括号保存对象；方括号保存数组 JSON 数据的书写格式是：名称/值对，名称/值对组合中的名称写在前面（在双引号中），值对写在后面(同样在双引号中)，中间用冒号隔开：值（value）可以是双引号括起来的字符串（string）、数值(number)、boolean、 null、对象（object）或者数组（array）。这些结构可以嵌套。 window.JSON是浏览器内置对象其中JSON.parse()表示把字符串解析为JSON对象，而JSON.stringify()表示将JSON对象解析为字符串 eval() 可以把字符串转为JSON 但不推荐使用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>字符串</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数与函数作用域]]></title>
    <url>%2F2017%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[函数声明与函数表达式的区别函数声明与函数表达式的区别在于: 函数声明是function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。如： 123function sayHi() &#123; console.log('hi');&#125; 而函数表达式采用的是变量赋值的写法：123var sayHi = function() &#123; console.log('hi');&#125; 这种写法将一个匿名函数赋值给变量，这个匿名函数又称为函数表达式。 由于函数声明前置，对于函数声明不必放到调用的前面，而函数表达式必须放到调用的前面。 变量声明前置与函数声明前置在一个作用域下，var 声明的变量和function 声明的函数会前置。 变量声明前置：使用var声明变量，变量声明会被提前到函数体的顶部，初始值为undefined而变量赋值操作留在原来的位置。 函数声明前置：采用function命令声明函数时，整个函数会被提升到当前作用域顶部，因此在声明函数之前调用函数也是可行的。 arguments 由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments为类数组对象，无法直接使用Aarry对象上的方法。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 但在严格模式下： 不允许对arguments赋值 1arguments++; // 语法错误 arguments不再追踪参数的变化 1234567891011 function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; "use strict"; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 函数重载的模拟JS没有重载机制，但我们可以模仿重载。 123456789101112131415function sum() &#123; if(arguments.length === 2) &#123; return arguments[0] + arguments[1]; &#125;else if(arguments.length === 3) &#123; return arguments[0] + arguments[1] + arguments[2]; &#125;else if(arguments.length === 4) &#123; return arguments[0] + arguments[1] + arguments[2] + arguments[3]; &#125;else &#123; return 0; &#125;&#125;sum(1,2); //3sum(1,2,3); //6sum(1,2,3,4); //10 立即执行函数表达式立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行；立即执行函数(immediate function)术语不是在ECMAScript标准中定义的，但它很短有助于描述和讨论模式；这种模式有一些几部分组成： 使用函数表达式定义一个函数(函数声明不能起作用) 在结尾加上一对括号，让函数立即被执行 将整个函数包裹在一对括号中(只有在你不将函数赋值给一个变量的时候才需要) 主要的作用是：隔离作用域。 相关面试题求n!，用递归来实现 123456 function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; return n * factorial(n-1);&#125; 写一个函数，返回参数的平方和1234567891011function sumOfSquares()&#123; var sum = 0; for(var i = 0; i &lt; arguments.length; i++) &#123; sum += Math.pow(arguments[i],2); &#125; return sum;&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result2) //10 变量声明提升123456789console.log(a);var a = 1;console.log(b);/* 输出： undefined b is not defined 原因是a声明前置，初始值为undefined，而b并没有声明*/ 函数声明提升12345678910111213141516 sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;;/* 输出： hello world sayAge is not a function 原因是sayName函数声明前置 而sayAge采用的是函数表达式的形式，必须要声明后才能调用*/ 如下代码输出什么? 写出作用域链查找过程伪代码12345678910111213141516171819202122232425262728293031323334353637383940var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;//作用域链过程伪代码：globalContext = &#123; AO: &#123; x: 10 foo: function bar: function &#125; Scope:null&#125;//声明foo时得到下面foo.[[scope]] = globalContext.AO//声明bar.[[scope]] = globalConetxt.AO//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 &#125; scope: globalConetext.AO&#125;//进入foo的执行上下文fooConetxt = &#123; AO: &#123; &#125; scope: globalConetext.AO&#125;故输出为： 10 如下代码输出什么? 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435var x = 10;bar()function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30; foo: function &#125; scope: globleContext.AO&#125;//进入foo的执行上下文fooContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;结果输出为: 30 以下代码输出什么? 写出作用域链的查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10;bar()function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125;//作用域链的查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 (anonymous): function &#125; scope: globleContext.AO&#125;//进入匿名函数执行上下文anonymousContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;所以最后输出: 30 以下代码输出什么？ 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; a: 1 fn: function fn3: function &#125; scope: null&#125;//声明fn时:fn.[[scope]]=globalContext.AO//声明fn3时:fn3.[[scope]]=globalContext.AO//开始进入fn的执行上下文fnContext = &#123; AO: &#123; a: undefined //输出undefined,变量声明提前 fn: function &#125; scope:globalContext.AO&#125;//声明a后fnContext = &#123; AO: &#123; a: 5 //输出5 fn: function &#125; scope: globalContext.AO&#125;//a++fnContext = &#123; AO: &#123; a: 6 fn: function &#125; scope: globalContext.AO&#125;//进入fn3的执行上下文fn3Context = &#123; Ao: &#123; &#125; scope: globalContext.AO //输出1 此后全局作用域下a:200&#125;//进入fn2的执行上下文fn2Context = &#123; AO: &#123; &#125; scope: fnContext.AO //输出6 此后fnContext.AO作用域下a:20&#125;//输出20 此后全局作用域下a:200//输出200即输出结果为：undefined 5 1 6 20 200]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>作用域</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种方式实现元素的垂直居中]]></title>
    <url>%2F2017%2F%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html</url>
    <content type="text"><![CDATA[HTML结构 123&lt;div class="container"&gt; &lt;div class="box"&gt;垂直居中&lt;/div&gt;&lt;/div&gt; flexbox布局1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; table-cell1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: table-cell; vertical-align: middle; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; 绝对定位负margin1234567891011121314151617.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; margin-left: -25px; margin-top: -25px;&#125; translate12345678910111213141516.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 与绝对定位负边距相似 绝对定位和0123456789101112131415161718.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0;&#125; 绝对定位，margin: auto; top, left, bottom, right均设为0, 子元素margin会撑开形成垂直居中 伪元素与inline-block123456789101112131415161718192021.container &#123; background-color: red; width: 200px; height: 200px; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; display: inline-block; vertical-align: middle;&#125;.container::after &#123; content: &apos;&apos;; display: inline-block; width: 0; height: 100%; vertical-align: middle;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[CSS hackCSS hack由于不同厂商的浏览器，比如IE, Safari, firefox, chorme，或同一厂商不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此能够导致生成页面效果不一样，得不到所需要的效果。这个时候我们需要针对不同浏览器写不同的CSS，让它能够同时兼容不同的浏览器，能在不同浏览器中也能得到我们想要的页面效果。 浏览器兼容的思路要不要做 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本角度（有无必要做某件事情） 做到什么程度 让哪些浏览器支持哪些效果 如何做 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、repond.js、css reset、normalize.css、Modernizr)、postCSS 条件注释、CSS hack、js能力检测做一些修补 列举5种以上浏览器兼容的写法 条件注释条件注释（Conditional comments）对IE的版本和IE非IE有优秀的区分能力，是WEB设计中常用的hack方法。 1234567891011&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt;用于 IE9 &lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt; 用于 IE7或更低版本 &lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;用于 IE8 或更高版本 &lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;用于 IE9 以下版本&lt;![endif]--&gt;&lt;!--[if !IE]&gt; --&gt;用于非 IE &lt;!-- &lt;![endif]--&gt;使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 CSS属性前缀法属性前缀法(即类内部Hack)：例如 IE6能识别下划线””和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识 123456.box&#123; color: red; _color: blue; /*ie6*/ *color: pink; /*ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 选择器前缀法（即选择器Hack） 例如 12IE6能识别*html .class&#123;&#125;，IE7能识别*+html .class&#123;&#125;或者*:first-child+html .class&#123;&#125;。 浏览器前缀 -webkit- ，针对safari，chrome浏览器的内核CSS写法 -moz-，针对firefox浏览器的内核CSS写法 -ms-，针对ie内核的CSS写法 -o-，针对Opera内核的CSS写法123456.box &#123; -moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; 4. 以下工具/名词是做什么的 条件注释 条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 IE Hack 针对IE浏览器编写不同的CSS以达到让IE正常解析CSS。 js 能力检测 识别浏览器的能力而不是识别特定的浏览器。只需根据浏览器支持的功能给出解决方案。 html5shiv.js 用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.js 用于为 IE6-8 以及其它不支持 CSS3 -媒体查询功能的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计。 css reset 去除浏览器的默认样式。 normalize.css Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 Modernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。 postCSS 它可以被理解为一个平台，可以让一些插件在上面跑，它提供了一个解析器，可以将CSS解析成抽象语法树，通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer，它可以帮我们处理兼容问题，只需正常写CSS，autoprefixer可以帮我的自动生成兼容性代码 查询属性兼容性http://caniuse.com/]]></content>
      <categories>
        <category>兼容性</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的CSS布局]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[五种方式实现三栏布局采用五种方式实现横向左右定宽，中间自适应的三栏布局 浮动 左右模块各自向左右浮动，并设置中间部分的左右margin值缺点是要按照left,right,main这样的顺序写HTML。 绝对定位 实用。 flexbox布局 要考虑兼容性的问题，对于移动端我一般采用这种方式来进行三栏布局。 table布局 缺点：无法设置main与两边的间隔 grid布局 缺点：兼容性有点尴尬啊。。 单栏布局 圣杯布局 main先加载，三个部分均左浮动，left和right设置负margin与main处在同一行，再通过相对定位调整位置。缺点是当页面缩小，页面结构会乱。 对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。 双飞翼布局 给main一个包裹层，设置左右margin，三个部分均浮动，其中左右定宽，中间100%,左右通过负margin回到合适的位置。 同样的，对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F%E6%B5%85%E6%9E%90%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?浮动的特征是使元素脱离普通流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素才停下来； 对父容器的影响: 父容器中的元素浮动后，脱离普通流会使得父容器失去高度； 对其他浮动元素的影响： 如果是同一方向浮动，相邻的浮动元素会并列在同一行，空间不够，会换到下一行 对普通元素的影响： 浮动元素会脱离普通流，普通元素会占据它原有的空间，从而会出现浮动元素覆盖普通元素 对文字的影响： 文字可以感知的浮动元素的存在，文字会在浮动元素周围形成环绕效果 清除浮动指什么? 如何清除浮动? 两种以上方法 清除浮动指的是通过clear属性解决由元素浮动引起的父容器的塌陷问题。 清楚浮动的方法： 方法一：父级元素定义：overflow: hidden; 方法二：使用伪元素 12345.container::after &#123; content: ''; display: block; clear: both;&#125; 方法三：在父元素末尾添加一个空div,设置样式clear: both (与方法二类似) 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ static: 默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明） relative: 生成相对定位元素，相对于元素本身正常位置进行定位。 absolute: 脱离普通流，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位,元素的位置通过 left, top, right 以及 bottom 属性进行规定 fixed: 绝对定位，脱离普通流，相对于浏览器窗口进行定位。元素的位置通过 left, top, right 以及 bottom 属性进行规定 sticky: CSS3新属性，表现类似position: relative和position: fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置 z-index 有什么作用? 如何使用?z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。元素可拥有负的 z-index 属性值。 应用 ：元素脱离了普通流，覆盖了普通元素，要修改显示顺序，可以为两者添加z-index属性值，其中属性值越大，显示的越靠前。 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别 position: relative: 相对于自身偏移，不脱离普通流，仍占据原有空间，不影响其他元素 负margin: 除了让元素自身发生偏移还影响其它普通流中的元素。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC(Block formatting context)直译为“块级格式化上下文 ”。BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。同时BFC任然属于文档中的普通流。 如何生成BFC：当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context float: 除了none以外的值 overflow除了visible意外的值（hidden, auto, scroll） display(table-cell, table-caption, inline-block) position(absolute, fixed) BFC的作用 阻止边距折叠： 我们知道在一般情况下，两个上下相邻的盒子会折叠它们垂直方向接触到的边距，这种情况只会发生在同一个Block Formatting Context中。换句话说，在同一个布局环境中（Block Formatting Context）是边距折叠的必要条件。这也就是为什么浮动的元素和绝对定位元素不会发生边距折叠的原因（当然还有很多种情况也不会折叠）。 可以包含浮动元素如: 阻止元素被浮动覆盖，如: 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。即：两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠 当然负margin的情况下也会出现margin合并的现象。 不让相邻元素外边距合并： 浮动元素、inline-block元素、绝对定位元素不会和垂直方向上其他元素的margin折叠(这里指的是上下相邻的元素) 创建了格式化上下文的元素，不和它的子元素发生margin折叠（这里指的是BFC的元素和它的子元素不会发生折叠）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>浮动</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些？ 块级元素：div, p, h1-h6, table, form, ul, li, ol, address, article, aside, audio, blockquote, canvas,header,footer等 行内元素: span, a, input, button, lable, select, textarea, em, br, img, strong 区别： 行内元素只能容纳行内元素和文本。而块级可以容纳块级元素和行内元素。 块级元素可以设定宽高，而行内元素不可以。 块级元素独占一行，而行内元素可以与其它行内元素共同处在一行。 行内元素的默认宽度为内容的宽度，块级元素默认宽度与浏览器窗口宽度一致 什么是 CSS 继承? 哪些属性能继承，哪些不能？ CSS继承: 子元素继承了父元素的CSS属性。 不可继承属性：display, margin, border, padding, background, width, height, overflow, z-index, float, position, vertical-align 所有元素可继承：visibility和cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中? 块级元素水平居中：给块级元素设定宽高,margin: 0 auto; 多个块级元素可以使用inline-block和flex 行内元素: text-align: center; 用 CSS 实现一个三角形 单行文本溢出加 …如何实现?12345.box &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; px, em, rem 有什么区别,如何理解dpr? px: 相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em: 指的是相对于其父级元素的大小，即倍数。 rem: 相对于根html元素的大小，即倍数。 dpr: 设备像素比。设备像素比 = 物理像素/设备独立像素(在某一方向上，x或y)，桌面端,CSS的1个像素都是对应着电脑屏幕的1个物理像素。而如果DPR为2时，CSS的1像素就会对应2物理像素。 解释下面代码的作用?为什么要加引号?字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 字体大小：12px 字体行距：1.5倍 字体选择的优先级从高到低：tahoma -&gt; … -&gt; sans-serif 字体描述需要加引号的情况，常见有下面几种： 字体描述使用的中文 字体描述使用英文，中间有空格 字体描述使用unicode编码\5b8b\4f53 是unicode编码模式，表示“宋体” 控制台中输入：escape(“字体”)将字体中文转换为unicode编码格式 常见样式实现按钮 三角形 实现Card text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是使得元素中的文本水平居中。作用在父元素上，能让行内元素以及块级元素中display为inline和inline-block元素居中。 IE 盒模型和W3C盒模型有什么区别? IE盒模型的宽度和高度包含border,padding和content 即：box-sizing: border-box; W3C盒模型只包含content部分的宽高 默认: box-sizing: content-box; *{ box-sizing: border-box;}的作用是什么？设置为以border,padding,content为宽高的盒模型。 line-height: 2和linde-height: 200%有什么区别？line-height: 2 表示根据子元素自己字体的大小乘以2来计算行高，而line-height: 200% 表示根据父元素的字体大小计算行高，并且子元素会继承父元素的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?inline-block使元素具有内联的特性时， 内容又具有块级元素的特性，可以设置宽高等； 去除缝隙有两种方法： 1.去除两元素间的空白字符， 2.将父元素的字体大小设置为0，再分别设置它们的字体大小； 高度不一样时，对具有inline-block属性的元素使用vertical-align: top使其对其。 CSS sprite 是什么?CSS精灵，指的是将多张图片拼接在一起，通过改变background-position来改变显示出来的图片，达到减少HTTP请求，提高页面性能的效果。 让一个元素”看不见”有几种方式？有什么区别?1234opacity: 0; 使元素变得透明，仍处在页面上display: none; 使元素在页面上消失,不占用空间visibility: hidden; 使元素不可见，但仍在页面上占据空间background-color: rgba(0, 0, 0, 0.2) 只是背景色透明]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class和id的使用场景？12class 用于选择页面上带相同类属性的元素，可以有多个id 它是唯一的，选择页面上唯一匹配id属性的元素 CSS选择器常见的有几种？1234567891011121. 元素选择器 如：p, h1, span2. 类选择器 .class-name3. id选择器 #id-name4. 通配选择器 *5. 属性选择器 E[attr], E[attr=value]等6. 组合选择器 E,F 多元素选择器 E F 后代选择器 E&gt;F 子元素选择器 E+F 相邻兄弟选择器 E~F 普通相邻选择器7. 伪类选择器 E:first-child, E:hover, E:nth-child(n)等8. 伪元素选择器 E::before, E::after 3. 选择器的优先级是怎样的?对于复杂场景如何计算优先级？要了解选择器的优先级，必须先知道CSS的特殊性，特殊性即CSS的优先级，而特殊性值的决定了CSS的优先级。如下：123456选择器的特殊性值表述为4个部分，用0,0,0,0表示。1. ID选择器的特殊性值，加0,1,0,0。2. 类选择器，属性选择器的特殊性值，加0,0,1,0。3. 元素和伪元素的特殊性值, 加0,0,0,1。4. 通配选择器*对特殊性没有贡献，即0,0,0,0。5. 最后一个比较特殊一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，可以用1,0,0,0表示。 场景下，如：12345678910111213&lt;body&gt; &lt;div class="demo"&gt; &lt;a href="#"&gt;demo&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; div a &#123; color: blue; /*这里的优先级为0,0,0,2*/ &#125; .demo a &#123; color: red; /*这里的优先级为0,0,1,1 故这个优先级较高*/ &#125;&lt;/style&gt; 再者，1,0,0,0是要比0,99,99,99优先级要高的，因此我们可以得出常见的选择器的优先级为：1234561. !important: 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式2. 内联样式3. ID选择器4. 类选择器，属性选择器5. 元素和伪元素选择器6. 通配选择器 4.a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？ css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性，根据（3）的优先级计算规则决定哪条规则起作用，当特殊性值也一样的时候，css规则会按顺序排序，后声明的规则优先级高 一个链接只有访问和未访问的状态，因此 :link 与 :visited 谁前谁后都可以。要保证点击后即active有样式变化，:active必须要覆盖:hover，因此:active要在:hover之后。要保证鼠标滑过有效果，:hover必须要在:link和:visited后。因此一般的顺序为： a:link a:visited a:hover a:active 有人将这个LVHT(LoVe HAte)称为“爱恨原则”。 5. 以下选择器分别是什么意思?123456789101112131415161718#header&#123; id为header的元素&#125;.header&#123; class为header的元素&#125;.header .logo&#123; class为header的所有class为logo的后代元素&#125;.header.mobile&#123; class同时包含header和mobile的元素&#125;.header p, .header h3&#123; class为header的后代元素中所有的p和h3元素&#125;#header .nav&gt;li&#123; id为header后代元素中class为.nav的子元素li&#125;#header a:hover&#123; id为header后代元素中a的伪类:hover&#125;#header .logo~p&#123; id为header的后代元素中与class为logo同级的p元素&#125;#header input[type="text"]&#123;&#125; id为header后代中type="text"的input的元素 列出你知道的伪类选择器 :hover :link :visited :active :focus :checked :enabled :first-of-type :first-child :nth-child(n) div:first-child和div:first-of-type的作用和区别 div:first-child 指的是当前元素父元素下的第一个子元素 div:first-of-type指的是当前元素父元素下拥有相同标签的第一个子元素 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;ct&quot;&gt; &lt;p class=&quot;item1&quot;&gt;aa&lt;/p&gt; &lt;h3 class=&quot;item1&quot;&gt;bb&lt;/h3&gt; &lt;h3 class=&quot;item1&quot;&gt;ccc&lt;/h3&gt; &lt;/div&gt; 原因是: .item1:first-child匹配了类为.item1的父元素的第一个子元素;.item:first-of-type匹配了类为.item1的父元素下各种相同标签的第一个子元素，即p和h3的第一个。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2FCSS%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式 1&lt;p style="background-color: red"&gt;&lt;/p&gt; 内部样式 123456&lt;style&gt; .demo &#123; margin: 0 auto; background-color: #ccc; &#125;&lt;/style&gt; 外部样式通过link引入外部css文件 123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/head&gt; @import引入 123&lt;style&gt; @import url(style.css);&lt;/style&gt; link和@import的区别： 引入的语法不同 link的语法为： 1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt; @import语法为: 123&lt;style type="text/css"&gt; @import url(style.css);&lt;/style&gt; link是html标签，link标签除了可以加载CSS外，还可以做很多事情，比如定义RSS，定义rel连接属性等；而@import看作是CSS的样式，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link支持使用JavaScript控制DOM去改变样式；而@import不支持。 link是html标签，无兼容性问题；@import是在CSS2.1提出的，低版本浏览器不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css 相对路径，当前文件夹内css文件夹内的a.css ./css/a.css 相对路径，同上 b.css 相对路径，当前文件夹下的b.css ../imgs/a.png 相对路径，上级目录下img文件夹下的a.png /Users/hunger/project/css/a.css 绝对路径，本地文件夹内的a.css /static/css/a.css 相对路径，在网站根目录的static文件夹下css文件夹下的a.css http://kmac007.com/8-1.png 绝对路径，指向网站上的图片 如果我想在kmac007.com上展示一个图片，需要怎么操作? 获取图片URL 打开kmac007 在body中加入img标签，URL为图片URL 修改URL为相对路径 列出5条以上html和 css 的书写规范1. CSS 文件使用无 BOM 的 UTF-8 编码。 2. 选择器 与 { 之间必须包含空格。 3. 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 4. 列表型属性值 书写在单行时，, 后必须跟一个空格。 5. 属性定义后必须以分号结尾。 6. 在可以使用缩写的情况下，尽量使用属性缩写。 7. 长度为 0 时须省略单位。 8. 表示小数时，可以省略小数点前的0]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表单的用法简介]]></title>
    <url>%2F2017%2FHTML%E8%A1%A8%E5%8D%95%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[标签用于用户输入创建HTML表单 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含 menus、textarea、fieldset和label元素。 表单用于向服务器传输数据 属性 属性 值 描述 action URL 规定当提交表单时向何处发送表单数据 autocomplete on off 规定是否启用表单的自动完成功能 method get post 规定用于发送form-data的HTTP方法 name form_name 规定表单名称 enctype application/x-www-form-urlencoded ; multipart/form-data ; text/plain 规定在发送表单数据之前如何对其进行编码。 inputtext, password, submit12345&lt;form action="form_action.php" method="get"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; checkbox1234&lt;form action="form_action.php" method="get"&gt; 汽车: &lt;input type="checkbox" name="Car"&gt; 飞机: &lt;input type="checkbox" name="Plane" checked="checked"&gt;&lt;/form&gt; radio1234&lt;form action="form_action.php" method="get"&gt; 男：&lt;input type="radio" checked="checked" name="Sex" value="male"&gt; 女: &lt;input type="radio" name="Sex" value="female"&gt;&lt;/form&gt; select12345678&lt;form&gt; &lt;select name="city"&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="guangzhou"&gt;广州&lt;/option&gt; &lt;option value="shenzhen" selected&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; textarea1&lt;textarea rows="10" cols="30"&gt; button123&lt;form&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2FHTML.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别 HTML：超文本标记语言（HyperText Markup Language）,是一种用于创建网页的标准标记语言，被涉及用来显示数据。 XML：可扩展标记语言（Extensible Markuo Language）,它被涉及用来传输和存储数据。它是对超文本标记语言的补充，是各种应用程序之间进行数据传输的常用工具。由于标签没有被预定义，使用者可以自行定义标签。 XHTML：可扩展的超文本标记语言（Extensible HyperText Markup Language）,HTML4 和XML1.0 重组而成。改进了HTML定义不规范，结构不严谨的缺点。它的语法更加严格，相对HTML的兼容性也不差。 怎样理解 HTML 语义化什么是语义化?根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化? 在没有CSS的情况下，页面也能呈现合理的结构 良好的用户体验，例如title、alt用于解释名词或解释图片信息 有利于SEO：有利于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重 用HTML开发特殊设备的网页时，有助于这些设备解析（如屏幕阅读器、盲人阅读器、移动设备等），使其能以合理的结构呈现 便于团队开发和维护，语义化更具可读性。 内容与样式分离的原则 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现内联样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 常见的meta标签 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 页面关键字 1&lt;meta name="keywords" content="your tags"&gt; 页面描述 1&lt;meta name="description" content="150 words"&gt; 声明文件编码 1&lt;meta charset="UTF-8"&gt; viewport:能优化移动浏览器显示 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 优先使用IE最新版本和Chrome 12345&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=6" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=7" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=8" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制 1&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!DOCTYPE html&gt; 的作用? 文档声明声明文档的解析类型(document.compatMode)，避免浏览器的混杂模式。 严格模式：浏览器使用W3C的标准解析渲染页面 混杂模式：浏览器使用自身的方式解析渲染页面 &lt;!DOCTYPE html&gt;的作用是声明该页面的HTML版本为HTML5如果没有&lt;!DOCTYPE html&gt;，那么compatMode默认是BackCompat，即为混杂模式，浏览器按照自己的方式解析渲染页面，那么在不同的浏览器下就会到显示不同的样式。而添加了&lt;!DOCTYPE html&gt;，浏览器就会遵循W3C标准来解析渲染页面。 浏览器乱码的原因是什么？如何解决页面的编码方式与浏览器的解码方式不匹配；解决方法为在中加1&lt;meta charset="文档编码方式"&gt; 常见浏览器及其内核 浏览器 内核 IE Trident Chrome WebKit Safari WebKit Firefox Gecko Opera Presto 其中国内的浏览器一般为WebKit/Trident的双内核，如360浏览器，QQ浏览器等 常见标签及其使用场景12345678910111213141516171819202122232425262728293031323334&lt;!--...--&gt;：注释&lt;!DOCTYPE&gt;：定义文档类型&lt;html&gt;： 定义 HTML 文档&lt;head&gt;：定义关于文档的信息&lt;body&gt;： 定义文档的主体&lt;header&gt;：定义了文档的头部区域&lt;section&gt;：&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;footer&gt;：定义 section 或 body的页脚。&lt;div&gt;： 定义文档中的节&lt;meta&gt;：定义关于 HTML 文档的元信息。&lt;title&gt;：定义文档的标题。&lt;link&gt;：定义文档与外部资源的关系&lt;script&gt;：定义客户端脚本。&lt;nav&gt;：定义导航链接的部分&lt;aside&gt;：定义页面的侧边栏内容&lt;a&gt;：定义超文本链接&lt;br&gt;： 定义换行&lt;button&gt;： 定义一个点击按钮&lt;canvas&gt;：定义图形,绘图&lt;form&gt;：定义了HTML文档的表单&lt;h1&gt; to &lt;h6&gt;：定义 HTML 标题&lt;iframe&gt;：定义内联框架&lt;img&gt;：定义图像&lt;input&gt;：定义输入控件&lt;label&gt;：定义 input 元素的标注&lt;li&gt;：定义列表的项目&lt;object&gt;：定义内嵌对象&lt;param&gt;：定义对象的参数。&lt;ol&gt;： 定义有序列表。&lt;p&gt;： 定义段落。&lt;select&gt;：定义选择列表（下拉列表）。&lt;option&gt;：定义选择列表中的选项。&lt;style&gt;：定义文档的样式信息。&lt;table&gt;： 定义表格。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>语义化</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入 URL 到页面展示发生了什么事情]]></title>
    <url>%2F2017%2F%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85.html</url>
    <content type="text"><![CDATA[这是一道经典的前端面试题，在学习的过程中，我想如果通过自己的语言来描述出来印象会更加深刻。 什么是URL URL(Uniform / Universal Resource Locator)统一资源定位符，如同在网络上的门牌，是因特网上标准的资源的地址。URL的标准格式如下：协议类型://服务器地址（必要时需加上端口号）/路径/文件名 例如：http://www.jianshu.com/users/78757d5285cd/timeline协议：http网络地址：www.jianshu.com资源路径：users/78757d5285cd/timeline 流程浏览器中输入URL并回车浏览器查找域名的IP地址1. 浏览器缓存 – 浏览器会缓存DNS记录一段时间 2. 系统缓存 - 从 Hosts 文件查找是否有该域名和对应 IP。 3. 路由器缓存 – 一般路由器也会缓存域名信息。 4. ISP DNS 缓存（互联网服务提供商的DNS缓存） – 比如到电信的 DNS 上查找缓存。 5. 如果都没有找到，则向根域名服务器查找域名对应 IP，根域名服务器把请求转发到下一级，直到找到 IP 浏览器发送一个HTTP请求到web服务器服务器处理 常见的 web服务器有 Apache、Nginx、IIS、Lighttpd web服务器接收用户的Request 交给网站代码，或者接受请求反向代理到其他 web服务器网站处理URL中的文件地址部分经过服务器上的路由程序重定向到对应的控制器(controller)对象,控制器对象根据URL中指定的操作执行相关的逻辑并调用目标数据的模型(Model)对象,模型对象与数据库交互完成目标操作后,控制器将模型中反馈的数据填充到视图中。视图部分(通常是HTML页面)作为HTTP响应发送到浏览器端。浏览器处理HTML字符串被浏览器接受后被一句句读取解析解析到link 标签后重新发送请求获取css解析到 script标签后发送请求获取 js，并执行代码解析到img 标签后发送请求获取图片资源绘制网页将渲染好的页面图像显示出来，并开始响应用户的操作。 以上只是一个简单的流程，过程中还会涉及到很多问题。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
        <tag>URL</tag>
      </tags>
  </entry>
</search>
