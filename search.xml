<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串与JSON相关操作]]></title>
    <url>%2F2017%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EJSON%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[使用数组拼接出如下字符串1&quot;&lt;dl class=&quot;product&quot;&gt;&lt;dt&gt;女装&lt;/dt&gt;&lt;dd&gt;短款&lt;/dd&gt;&lt;dd&gt;冬季&lt;/dd&gt;&lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt;&quot; 12345678910111213141516var prod = &#123; name: '女装', styles: ['短款', '冬季', '春装']&#125;function getTplStr(data) &#123; var arr = [] arr.push('&lt;dl class="product"&gt;') arr.push('&lt;dt&gt;' + data.name + '&lt;/dt&gt;') for (key in data['styles']) &#123; arr.push('&lt;dd&gt;' + data['styles'][key] + '&lt;/dd&gt;') &#125; arr.push("&lt;/dl&gt;") return arr.join('')&#125;var result = getTplStr(prod) //result拼接后的字符串 写出两种以上声明多行字符串的方法12345678910111213141516171819202122232425262728293031/*使用\n转义字符回车*/var str1 = "line1\nline2\nline3\n"console.log(str1)/*使用反斜杠转义*/var str2 = "line1\ line2\ line3\"console.log(str2)/*连接运算符(+)*/var str3 = "line1" + "line2" + "line3"console.log(str3)/*使用多行注释，生成多行字符串*/var str4 = (function()&#123;/* line1 line2 line3*/&#125;).toString().split('\n').slice(1,-1).join('\n')/*使用ES6的字符串扩展*/var str5 = ` line1 line2 line3`console.log(str5) 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是12345678910function isPalindrome(str) &#123; if (typeof str === "string") &#123; var newStr = str.toLowerCase().split('').reverse().join('') if(newStr === str.toLowerCase()) &#123; console.log("是回文") &#125;else &#123; console.log("不是回文") &#125; &#125;&#125; 写一个函数，统计字符串里出现出现频率最多的字符12345678910111213141516171819function isMost(str) &#123; var dict = &#123;&#125; for (var i = 0; i &lt; str.length; i++) &#123; if(dict[str[i]]) &#123; ++dict[str[i]] &#125;else&#123; dict[str[i]] = 1 &#125; &#125; var count = 0 var maxValue for(var key in dict)&#123; if(dict[key] &gt; count)&#123; maxValue = key count = dict[key] &#125; &#125; return maxValue + &quot;:&quot; + count&#125; 7. 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如12camelize(&quot;background-color&quot;) == &apos;backgroundColor&apos;camelize(&quot;list-style-image&quot;) == &apos;listStyleImage&apos; 代码如下:12345678function camelize(str) &#123; var arr = str.toLowerCase().split(&apos;-&apos;) var newStr = arr[0] for (var i = 1; i &lt; arr.length; i++) &#123; newStr += (arr[i].charAt(0).toUpperCase() + arr[i].substring(1)) &#125; return newStr&#125; 8. 写一个 ucFirst函数，返回第一个字母为大写的字符 （*）1ucFirst(&quot;hunger&quot;) == &quot;Hunger&quot; 代码如下：123function ucFirst(str) &#123; return str.charAt(0).toUpperCase() + str.substring(1)&#125; 9. 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如12truncate(&quot;hello, this is hunger valley,&quot;, 10) == &quot;hello, thi...&quot;;truncate(&quot;hello world&quot;, 20) == &quot;hello world&quot; 代码如下:1234567function truncate(str, maxlength) &#123; if (str.length &gt; maxlength) &#123; return str.substring(0, maxlength) + &quot;...&quot; &#125; else &#123; return str &#125;&#125; 10. 什么是 json？什么是 json 语言？JSON 语言如何表示对象？window.JSON 是什么？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集.JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 严格的JavaScript对象表示法表示结构化的数据。具体写法是：数据在名称/值对中；数据由逗号分隔；花括号保存对象；方括号保存数组 JSON 数据的书写格式是：名称/值对，名称/值对组合中的名称写在前面（在双引号中），值对写在后面(同样在双引号中)，中间用冒号隔开：值（value）可以是双引号括起来的字符串（string）、数值(number)、boolean、 null、对象（object）或者数组（array）。这些结构可以嵌套。 window.JSON是浏览器内置对象其中JSON.parse()表示把字符串解析为JSON对象，而JSON.stringify()表示将JSON对象解析为字符串 11. 如何把JSON 格式的字符串转换为 JS 对象？如何把 JS对象转换为 JSON 格式的字符串?JSON.parse() 把JSON 格式的字符串转换为 JS 对象 JSON.stringify() 如何把 JS对象转换为 JSON 格式的字符串 eval() 可以把字符串转为json 但不推荐使用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavsScript</tag>
        <tag>字符串</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数与函数作用域]]></title>
    <url>%2F2017%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[函数声明与函数表达式的区别函数声明与函数表达式的区别在于: 函数声明是function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。如： 123function sayHi() &#123; console.log('hi');&#125; 而函数表达式采用的是变量赋值的写法： 123var sayHi = function() &#123; console.log('hi');&#125; 这种写法将一个匿名函数赋值给变量，这个匿名函数又称为函数表达式。 由于函数声明前置，对于函数声明不必放到调用的前面，而函数表达式必须放到调用的前面。 变量声明前置与函数声明前置在一个作用域下，var 声明的变量和function 声明的函数会前置。 变量声明前置：使用var声明变量，变量声明会被提前到函数体的顶部，初始值为undefined而变量赋值操作留在原来的位置。 函数声明前置：采用function命令声明函数时，整个函数会被提升到当前作用域顶部，因此在声明函数之前调用函数也是可行的。 arguments 由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments为类数组对象，无法直接使用Aarry对象上的方法。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 但在严格模式下： 不允许对arguments赋值 1arguments++; // 语法错误 arguments不再追踪参数的变化 1234567891011 function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; "use strict"; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 函数重载的模拟JS没有重载机制，但我们可以模仿重载。 123456789101112131415function sum() &#123; if(arguments.length === 2) &#123; return arguments[0] + arguments[1]; &#125;else if(arguments.length === 3) &#123; return arguments[0] + arguments[1] + arguments[2]; &#125;else if(arguments.length === 4) &#123; return arguments[0] + arguments[1] + arguments[2] + arguments[3]; &#125;else &#123; return 0; &#125;&#125;sum(1,2); //3sum(1,2,3); //6sum(1,2,3,4); //10 立即执行函数表达式立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行；立即执行函数(immediate function)术语不是在ECMAScript标准中定义的，但它很短有助于描述和讨论模式；这种模式有一些几部分组成： 使用函数表达式定义一个函数(函数声明不能起作用) 在结尾加上一对括号，让函数立即被执行 将整个函数包裹在一对括号中(只有在你不将函数赋值给一个变量的时候才需要) 主要的作用是：隔离作用域。 相关面试题求n!，用递归来实现 123456 function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; return n * factorial(n-1);&#125; 写一个函数，返回参数的平方和1234567891011function sumOfSquares()&#123; var sum = 0; for(var i = 0; i &lt; arguments.length; i++) &#123; sum += Math.pow(arguments[i],2); &#125; return sum;&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result2) //10 变量声明提升123456789console.log(a);var a = 1;console.log(b);/* 输出： undefined b is not defined 原因是a声明前置，初始值为undefined，而b并没有声明*/ 函数声明提升12345678910111213141516 sayName('world');sayAge(10);function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;;/* 输出： hello world sayAge is not a function 原因是sayName函数声明前置 而sayAge采用的是函数表达式的形式，必须要声明后才能调用*/ 如下代码输出什么? 写出作用域链查找过程伪代码12345678910111213141516171819202122232425262728293031323334353637383940var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;//作用域链过程伪代码：globalContext = &#123; AO: &#123; x: 10 foo: function bar: function &#125; Scope:null&#125;//声明foo时得到下面foo.[[scope]] = globalContext.AO//声明bar.[[scope]] = globalConetxt.AO//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 &#125; scope: globalConetext.AO&#125;//进入foo的执行上下文fooConetxt = &#123; AO: &#123; &#125; scope: globalConetext.AO&#125;故输出为： 10 如下代码输出什么? 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435var x = 10;bar()function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30; foo: function &#125; scope: globleContext.AO&#125;//进入foo的执行上下文fooContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;结果输出为: 30 以下代码输出什么? 写出作用域链的查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10;bar()function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125;//作用域链的查找过程伪代码：globleContext = &#123; AO: &#123; x: 10 bar: function &#125; scope: null&#125;//进入bar的执行上下文barContext = &#123; AO: &#123; x: 30 (anonymous): function &#125; scope: globleContext.AO&#125;//进入匿名函数执行上下文anonymousContext = &#123; AO: &#123; &#125; scope: barContext.AO&#125;所以最后输出: 30 以下代码输出什么？ 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)//作用域链查找过程伪代码：globleContext = &#123; AO: &#123; a: 1 fn: function fn3: function &#125; scope: null&#125;//声明fn时:fn.[[scope]]=globalContext.AO//声明fn3时:fn3.[[scope]]=globalContext.AO//开始进入fn的执行上下文fnContext = &#123; AO: &#123; a: undefined //输出undefined,变量声明提前 fn: function &#125; scope:globalContext.AO&#125;//声明a后fnContext = &#123; AO: &#123; a: 5 //输出5 fn: function &#125; scope: globalContext.AO&#125;//a++fnContext = &#123; AO: &#123; a: 6 fn: function &#125; scope: globalContext.AO&#125;//进入fn3的执行上下文fn3Context = &#123; Ao: &#123; &#125; scope: globalContext.AO //输出1 此后全局作用域下a:200&#125;//进入fn2的执行上下文fn2Context = &#123; AO: &#123; &#125; scope: fnContext.AO //输出6 此后fnContext.AO作用域下a:20&#125;//输出20 此后全局作用域下a:200//输出200即输出结果为：undefined 5 1 6 20 200]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>作用域</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种方式实现元素的垂直居中]]></title>
    <url>%2F2017%2F%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html</url>
    <content type="text"><![CDATA[HTML结构 123&lt;div class="container"&gt; &lt;div class="box"&gt;垂直居中&lt;/div&gt;&lt;/div&gt; flexbox布局1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; table-cell1234567891011121314.container &#123; background-color: red; width: 200px; height: 200px; display: table-cell; vertical-align: middle; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px;&#125; 绝对定位负margin1234567891011121314151617.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; margin-left: -25px; margin-top: -25px;&#125; translate12345678910111213141516.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 与绝对定位负边距相似 绝对定位和0123456789101112131415161718.container &#123; background-color: red; width: 200px; height: 200px; position: relative;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0;&#125; 绝对定位，margin: auto; top, left, bottom, right均设为0, 子元素margin会撑开形成垂直居中 伪元素与inline-block123456789101112131415161718192021.container &#123; background-color: red; width: 200px; height: 200px; text-align: center;&#125;.box &#123; background-color: #000; color: #fff; width: 50px; height: 50px; display: inline-block; vertical-align: middle;&#125;.container::after &#123; content: &apos;&apos;; display: inline-block; width: 0; height: 100%; vertical-align: middle;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[CSS hackCSS hack由于不同厂商的浏览器，比如IE, Safari, firefox, chorme，或同一厂商不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此能够导致生成页面效果不一样，得不到所需要的效果。这个时候我们需要针对不同浏览器写不同的CSS，让它能够同时兼容不同的浏览器，能在不同浏览器中也能得到我们想要的页面效果。 浏览器兼容的思路要不要做 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本角度（有无必要做某件事情） 做到什么程度 让哪些浏览器支持哪些效果 如何做 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、repond.js、css reset、normalize.css、Modernizr)、postCSS 条件注释、CSS hack、js能力检测做一些修补 列举5种以上浏览器兼容的写法 条件注释条件注释（Conditional comments）对IE的版本和IE非IE有优秀的区分能力，是WEB设计中常用的hack方法。 1234567891011&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt;用于 IE9 &lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt; 用于 IE7或更低版本 &lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;用于 IE8 或更高版本 &lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;用于 IE9 以下版本&lt;![endif]--&gt;&lt;!--[if !IE]&gt; --&gt;用于非 IE &lt;!-- &lt;![endif]--&gt;使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 CSS属性前缀法属性前缀法(即类内部Hack)：例如 IE6能识别下划线””和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识 123456.box&#123; color: red; _color: blue; /*ie6*/ *color: pink; /*ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 选择器前缀法（即选择器Hack） 例如 12IE6能识别*html .class&#123;&#125;，IE7能识别*+html .class&#123;&#125;或者*:first-child+html .class&#123;&#125;。 浏览器前缀 -webkit- ，针对safari，chrome浏览器的内核CSS写法 -moz-，针对firefox浏览器的内核CSS写法 -ms-，针对ie内核的CSS写法 -o-，针对Opera内核的CSS写法123456.box &#123; -moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; 4. 以下工具/名词是做什么的 条件注释 条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。使用了条件注释的页面在 Windows Internet Explorer 9 中可正常工作，但在 Internet Explorer 10 中无法正常工作。 IE10不再支持条件注释 IE Hack 针对IE浏览器编写不同的CSS以达到让IE正常解析CSS。 js 能力检测 识别浏览器的能力而不是识别特定的浏览器。只需根据浏览器支持的功能给出解决方案。 html5shiv.js 用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.js 用于为 IE6-8 以及其它不支持 CSS3 -媒体查询功能的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计。 css reset 去除浏览器的默认样式。 normalize.css Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 Modernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。 postCSS 它可以被理解为一个平台，可以让一些插件在上面跑，它提供了一个解析器，可以将CSS解析成抽象语法树，通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer，它可以帮我们处理兼容问题，只需正常写CSS，autoprefixer可以帮我的自动生成兼容性代码 查询属性兼容性http://caniuse.com/]]></content>
      <categories>
        <category>兼容性</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的CSS布局]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[五种方式实现三栏布局采用五种方式实现横向左右定宽，中间自适应的三栏布局 浮动 左右模块各自向左右浮动，并设置中间部分的左右margin值缺点是要按照left,right,main这样的顺序写HTML。 绝对定位 实用。 flexbox布局 要考虑兼容性的问题，对于移动端我一般采用这种方式来进行三栏布局。 table布局 缺点：无法设置main与两边的间隔 grid布局 缺点：兼容性有点尴尬啊。。 单栏布局 圣杯布局 main先加载，三个部分均左浮动，left和right设置负margin与main处在同一行，再通过相对定位调整位置。缺点是当页面缩小，页面结构会乱。 对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。 双飞翼布局 给main一个包裹层，设置左右margin，三个部分均浮动，其中左右定宽，中间100%,左右通过负margin回到合适的位置。 同样的，对于这种方法。。有之前那么多种优秀的方法，迫不得已我是不会用的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F%E6%B5%85%E6%9E%90%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?浮动的特征是使元素脱离普通流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素才停下来； 对父容器的影响: 父容器中的元素浮动后，脱离普通流会使得父容器失去高度； 对其他浮动元素的影响： 如果是同一方向浮动，相邻的浮动元素会并列在同一行，空间不够，会换到下一行 对普通元素的影响： 浮动元素会脱离普通流，普通元素会占据它原有的空间，从而会出现浮动元素覆盖普通元素 对文字的影响： 文字可以感知的浮动元素的存在，文字会在浮动元素周围形成环绕效果 清除浮动指什么? 如何清除浮动? 两种以上方法 清除浮动指的是通过clear属性解决由元素浮动引起的父容器的塌陷问题。 清楚浮动的方法： 方法一：父级元素定义：overflow: hidden; 方法二：使用伪元素 12345.container::after &#123; content: ''; display: block; clear: both;&#125; 方法三：在父元素末尾添加一个空div,设置样式clear: both (与方法二类似) 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ static: 默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明） relative: 生成相对定位元素，相对于元素本身正常位置进行定位。 absolute: 脱离普通流，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位,元素的位置通过 left, top, right 以及 bottom 属性进行规定 fixed: 绝对定位，脱离普通流，相对于浏览器窗口进行定位。元素的位置通过 left, top, right 以及 bottom 属性进行规定 sticky: CSS3新属性，表现类似position: relative和position: fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置 z-index 有什么作用? 如何使用?z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。元素可拥有负的 z-index 属性值。 应用 ：元素脱离了普通流，覆盖了普通元素，要修改显示顺序，可以为两者添加z-index属性值，其中属性值越大，显示的越靠前。 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别 position: relative: 相对于自身偏移，不脱离普通流，仍占据原有空间，不影响其他元素 负margin: 除了让元素自身发生偏移还影响其它普通流中的元素。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC(Block formatting context)直译为“块级格式化上下文 ”。BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。同时BFC任然属于文档中的普通流。 如何生成BFC：当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context float: 除了none以外的值 overflow除了visible意外的值（hidden, auto, scroll） display(table-cell, table-caption, inline-block) position(absolute, fixed) BFC的作用 阻止边距折叠： 我们知道在一般情况下，两个上下相邻的盒子会折叠它们垂直方向接触到的边距，这种情况只会发生在同一个Block Formatting Context中。换句话说，在同一个布局环境中（Block Formatting Context）是边距折叠的必要条件。这也就是为什么浮动的元素和绝对定位元素不会发生边距折叠的原因（当然还有很多种情况也不会折叠）。 可以包含浮动元素如: 阻止元素被浮动覆盖，如: 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。即：两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠 当然负margin的情况下也会出现margin合并的现象。 不让相邻元素外边距合并： 浮动元素、inline-block元素、绝对定位元素不会和垂直方向上其他元素的margin折叠(这里指的是上下相邻的元素) 创建了格式化上下文的元素，不和它的子元素发生margin折叠（这里指的是BFC的元素和它的子元素不会发生折叠）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>浮动</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式]]></title>
    <url>%2F2017%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些？ 块级元素：div, p, h1-h6, table, form, ul, li, ol, address, article, aside, audio, blockquote, canvas,header,footer等 行内元素: span, a, input, button, lable, select, textarea, em, br, img, strong 区别： 行内元素只能容纳行内元素和文本。而块级可以容纳块级元素和行内元素。 块级元素可以设定宽高，而行内元素不可以。 块级元素独占一行，而行内元素可以与其它行内元素共同处在一行。 行内元素的默认宽度为内容的宽度，块级元素默认宽度与浏览器窗口宽度一致 什么是 CSS 继承? 哪些属性能继承，哪些不能？ CSS继承: 子元素继承了父元素的CSS属性。 不可继承属性：display, margin, border, padding, background, width, height, overflow, z-index, float, position, vertical-align 所有元素可继承：visibility和cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中? 块级元素水平居中：给块级元素设定宽高,margin: 0 auto; 多个块级元素可以使用inline-block和flex 行内元素: text-align: center; 用 CSS 实现一个三角形 单行文本溢出加 …如何实现?12345.box &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; px, em, rem 有什么区别,如何理解dpr? px: 相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em: 指的是相对于其父级元素的大小，即倍数。 rem: 相对于根html元素的大小，即倍数。 dpr: 设备像素比。设备像素比 = 物理像素/设备独立像素(在某一方向上，x或y)，桌面端,CSS的1个像素都是对应着电脑屏幕的1个物理像素。而如果DPR为2时，CSS的1像素就会对应2物理像素。 解释下面代码的作用?为什么要加引号?字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 字体大小：12px 字体行距：1.5倍 字体选择的优先级从高到低：tahoma -&gt; … -&gt; sans-serif 字体描述需要加引号的情况，常见有下面几种： 字体描述使用的中文 字体描述使用英文，中间有空格 字体描述使用unicode编码\5b8b\4f53 是unicode编码模式，表示“宋体” 控制台中输入：escape(“字体”)将字体中文转换为unicode编码格式 常见样式实现按钮 三角形 实现Card text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是使得元素中的文本水平居中。作用在父元素上，能让行内元素以及块级元素中display为inline和inline-block元素居中。 IE 盒模型和W3C盒模型有什么区别? IE盒模型的宽度和高度包含border,padding和content 即：box-sizing: border-box; W3C盒模型只包含content部分的宽高 默认: box-sizing: content-box; *{ box-sizing: border-box;}的作用是什么？设置为以border,padding,content为宽高的盒模型。 line-height: 2和linde-height: 200%有什么区别？line-height: 2 表示根据子元素自己字体的大小乘以2来计算行高，而line-height: 200% 表示根据父元素的字体大小计算行高，并且子元素会继承父元素的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?inline-block使元素具有内联的特性时， 内容又具有块级元素的特性，可以设置宽高等； 去除缝隙有两种方法： 1.去除两元素间的空白字符， 2.将父元素的字体大小设置为0，再分别设置它们的字体大小； 高度不一样时，对具有inline-block属性的元素使用vertical-align: top使其对其。 CSS sprite 是什么?CSS精灵，指的是将多张图片拼接在一起，通过改变background-position来改变显示出来的图片，达到减少HTTP请求，提高页面性能的效果。 让一个元素”看不见”有几种方式？有什么区别?1234opacity: 0; 使元素变得透明，仍处在页面上display: none; 使元素在页面上消失,不占用空间visibility: hidden; 使元素不可见，但仍在页面上占据空间background-color: rgba(0, 0, 0, 0.2) 只是背景色透明]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class和id的使用场景？12class 用于选择页面上带相同类属性的元素，可以有多个id 它是唯一的，选择页面上唯一匹配id属性的元素 CSS选择器常见的有几种？1234567891011121. 元素选择器 如：p, h1, span2. 类选择器 .class-name3. id选择器 #id-name4. 通配选择器 *5. 属性选择器 E[attr], E[attr=value]等6. 组合选择器 E,F 多元素选择器 E F 后代选择器 E&gt;F 子元素选择器 E+F 相邻兄弟选择器 E~F 普通相邻选择器7. 伪类选择器 E:first-child, E:hover, E:nth-child(n)等8. 伪元素选择器 E::before, E::after 3. 选择器的优先级是怎样的?对于复杂场景如何计算优先级？要了解选择器的优先级，必须先知道CSS的特殊性，特殊性即CSS的优先级，而特殊性值的决定了CSS的优先级。如下：123456选择器的特殊性值表述为4个部分，用0,0,0,0表示。1. ID选择器的特殊性值，加0,1,0,0。2. 类选择器，属性选择器的特殊性值，加0,0,1,0。3. 元素和伪元素的特殊性值, 加0,0,0,1。4. 通配选择器*对特殊性没有贡献，即0,0,0,0。5. 最后一个比较特殊一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，可以用1,0,0,0表示。 场景下，如：12345678910111213&lt;body&gt; &lt;div class="demo"&gt; &lt;a href="#"&gt;demo&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; div a &#123; color: blue; /*这里的优先级为0,0,0,2*/ &#125; .demo a &#123; color: red; /*这里的优先级为0,0,1,1 故这个优先级较高*/ &#125;&lt;/style&gt; 再者，1,0,0,0是要比0,99,99,99优先级要高的，因此我们可以得出常见的选择器的优先级为：1234561. !important: 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式2. 内联样式3. ID选择器4. 类选择器，属性选择器5. 元素和伪元素选择器6. 通配选择器 4.a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？ css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性，根据（3）的优先级计算规则决定哪条规则起作用，当特殊性值也一样的时候，css规则会按顺序排序，后声明的规则优先级高 一个链接只有访问和未访问的状态，因此 :link 与 :visited 谁前谁后都可以。要保证点击后即active有样式变化，:active必须要覆盖:hover，因此:active要在:hover之后。要保证鼠标滑过有效果，:hover必须要在:link和:visited后。因此一般的顺序为： a:link a:visited a:hover a:active 有人将这个LVHT(LoVe HAte)称为“爱恨原则”。 5. 以下选择器分别是什么意思?123456789101112131415161718#header&#123; id为header的元素&#125;.header&#123; class为header的元素&#125;.header .logo&#123; class为header的所有class为logo的后代元素&#125;.header.mobile&#123; class同时包含header和mobile的元素&#125;.header p, .header h3&#123; class为header的后代元素中所有的p和h3元素&#125;#header .nav&gt;li&#123; id为header后代元素中class为.nav的子元素li&#125;#header a:hover&#123; id为header后代元素中a的伪类:hover&#125;#header .logo~p&#123; id为header的后代元素中与class为logo同级的p元素&#125;#header input[type="text"]&#123;&#125; id为header后代中type="text"的input的元素 列出你知道的伪类选择器 :hover :link :visited :active :focus :checked :enabled :first-of-type :first-child :nth-child(n) div:first-child和div:first-of-type的作用和区别 div:first-child 指的是当前元素父元素下的第一个子元素 div:first-of-type指的是当前元素父元素下拥有相同标签的第一个子元素 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;ct&quot;&gt; &lt;p class=&quot;item1&quot;&gt;aa&lt;/p&gt; &lt;h3 class=&quot;item1&quot;&gt;bb&lt;/h3&gt; &lt;h3 class=&quot;item1&quot;&gt;ccc&lt;/h3&gt; &lt;/div&gt; 原因是: .item1:first-child匹配了类为.item1的父元素的第一个子元素;.item:first-of-type匹配了类为.item1的父元素下各种相同标签的第一个子元素，即p和h3的第一个。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2FCSS%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式 1&lt;p style="background-color: red"&gt;&lt;/p&gt; 内部样式 123456&lt;style&gt; .demo &#123; margin: 0 auto; background-color: #ccc; &#125;&lt;/style&gt; 外部样式通过link引入外部css文件 123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="index.css"&gt;&lt;/head&gt; @import引入 123&lt;style&gt; @import url(style.css);&lt;/style&gt; link和@import的区别： 引入的语法不同 link的语法为： 1&lt;link rel="stylesheet" type="text/css" href="index.css"&gt; @import语法为: 123&lt;style type="text/css"&gt; @import url(style.css);&lt;/style&gt; link是html标签，link标签除了可以加载CSS外，还可以做很多事情，比如定义RSS，定义rel连接属性等；而@import看作是CSS的样式，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link支持使用JavaScript控制DOM去改变样式；而@import不支持。 link是html标签，无兼容性问题；@import是在CSS2.1提出的，低版本浏览器不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css 相对路径，当前文件夹内css文件夹内的a.css ./css/a.css 相对路径，同上 b.css 相对路径，当前文件夹下的b.css ../imgs/a.png 相对路径，上级目录下img文件夹下的a.png /Users/hunger/project/css/a.css 绝对路径，本地文件夹内的a.css /static/css/a.css 相对路径，在网站根目录的static文件夹下css文件夹下的a.css http://kmac007.com/8-1.png 绝对路径，指向网站上的图片 如果我想在kmac007.com上展示一个图片，需要怎么操作? 获取图片URL 打开kmac007 在body中加入img标签，URL为图片URL 修改URL为相对路径 列出5条以上html和 css 的书写规范1. CSS 文件使用无 BOM 的 UTF-8 编码。 2. 选择器 与 { 之间必须包含空格。 3. 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 4. 列表型属性值 书写在单行时，, 后必须跟一个空格。 5. 属性定义后必须以分号结尾。 6. 在可以使用缩写的情况下，尽量使用属性缩写。 7. 长度为 0 时须省略单位。 8. 表示小数时，可以省略小数点前的0]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表单的用法简介]]></title>
    <url>%2F2017%2FHTML%E8%A1%A8%E5%8D%95%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[标签用于用户输入创建HTML表单 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含 menus、textarea、fieldset和label元素。 表单用于向服务器传输数据 属性 属性 值 描述 action URL 规定当提交表单时向何处发送表单数据 autocomplete on off 规定是否启用表单的自动完成功能 method get post 规定用于发送form-data的HTTP方法 name form_name 规定表单名称 enctype application/x-www-form-urlencoded ; multipart/form-data ; text/plain 规定在发送表单数据之前如何对其进行编码。 inputtext, password, submit12345&lt;form action="form_action.php" method="get"&gt; 用户名：&lt;input type="text" name="username"&gt; 密码：&lt;input type="password" name="password"&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; checkbox1234&lt;form action="form_action.php" method="get"&gt; 汽车: &lt;input type="checkbox" name="Car"&gt; 飞机: &lt;input type="checkbox" name="Plane" checked="checked"&gt;&lt;/form&gt; radio1234&lt;form action="form_action.php" method="get"&gt; 男：&lt;input type="radio" checked="checked" name="Sex" value="male"&gt; 女: &lt;input type="radio" name="Sex" value="female"&gt;&lt;/form&gt; select12345678&lt;form&gt; &lt;select name="city"&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="guangzhou"&gt;广州&lt;/option&gt; &lt;option value="shenzhen" selected&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; textarea1&lt;textarea rows="10" cols="30"&gt; button123&lt;form&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2FHTML.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别 HTML：超文本标记语言（HyperText Markup Language）,是一种用于创建网页的标准标记语言，被涉及用来显示数据。 XML：可扩展标记语言（Extensible Markuo Language）,它被涉及用来传输和存储数据。它是对超文本标记语言的补充，是各种应用程序之间进行数据传输的常用工具。由于标签没有被预定义，使用者可以自行定义标签。 XHTML：可扩展的超文本标记语言（Extensible HyperText Markup Language）,HTML4 和XML1.0 重组而成。改进了HTML定义不规范，结构不严谨的缺点。它的语法更加严格，相对HTML的兼容性也不差。 怎样理解 HTML 语义化什么是语义化?根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化? 在没有CSS的情况下，页面也能呈现合理的结构 良好的用户体验，例如title、alt用于解释名词或解释图片信息 有利于SEO：有利于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重 用HTML开发特殊设备的网页时，有助于这些设备解析（如屏幕阅读器、盲人阅读器、移动设备等），使其能以合理的结构呈现 便于团队开发和维护，语义化更具可读性。 内容与样式分离的原则 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现内联样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 常见的meta标签 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 页面关键字 1&lt;meta name="keywords" content="your tags"&gt; 页面描述 1&lt;meta name="description" content="150 words"&gt; 声明文件编码 1&lt;meta charset="UTF-8"&gt; viewport:能优化移动浏览器显示 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 优先使用IE最新版本和Chrome 12345&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=6" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=7" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=8" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制 1&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!DOCTYPE html&gt; 的作用? 文档声明声明文档的解析类型(document.compatMode)，避免浏览器的混杂模式。 严格模式：浏览器使用W3C的标准解析渲染页面 混杂模式：浏览器使用自身的方式解析渲染页面 &lt;!DOCTYPE html&gt;的作用是声明该页面的HTML版本为HTML5如果没有&lt;!DOCTYPE html&gt;，那么compatMode默认是BackCompat，即为混杂模式，浏览器按照自己的方式解析渲染页面，那么在不同的浏览器下就会到显示不同的样式。而添加了&lt;!DOCTYPE html&gt;，浏览器就会遵循W3C标准来解析渲染页面。 浏览器乱码的原因是什么？如何解决页面的编码方式与浏览器的解码方式不匹配；解决方法为在中加1&lt;meta charset="文档编码方式"&gt; 常见浏览器及其内核 浏览器 内核 IE Trident Chrome WebKit Safari WebKit Firefox Gecko Opera Presto 其中国内的浏览器一般为WebKit/Trident的双内核，如360浏览器，QQ浏览器等 常见标签及其使用场景12345678910111213141516171819202122232425262728293031323334&lt;!--...--&gt;：注释&lt;!DOCTYPE&gt;：定义文档类型&lt;html&gt;： 定义 HTML 文档&lt;head&gt;：定义关于文档的信息&lt;body&gt;： 定义文档的主体&lt;header&gt;：定义了文档的头部区域&lt;section&gt;：&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;footer&gt;：定义 section 或 body的页脚。&lt;div&gt;： 定义文档中的节&lt;meta&gt;：定义关于 HTML 文档的元信息。&lt;title&gt;：定义文档的标题。&lt;link&gt;：定义文档与外部资源的关系&lt;script&gt;：定义客户端脚本。&lt;nav&gt;：定义导航链接的部分&lt;aside&gt;：定义页面的侧边栏内容&lt;a&gt;：定义超文本链接&lt;br&gt;： 定义换行&lt;button&gt;： 定义一个点击按钮&lt;canvas&gt;：定义图形,绘图&lt;form&gt;：定义了HTML文档的表单&lt;h1&gt; to &lt;h6&gt;：定义 HTML 标题&lt;iframe&gt;：定义内联框架&lt;img&gt;：定义图像&lt;input&gt;：定义输入控件&lt;label&gt;：定义 input 元素的标注&lt;li&gt;：定义列表的项目&lt;object&gt;：定义内嵌对象&lt;param&gt;：定义对象的参数。&lt;ol&gt;： 定义有序列表。&lt;p&gt;： 定义段落。&lt;select&gt;：定义选择列表（下拉列表）。&lt;option&gt;：定义选择列表中的选项。&lt;style&gt;：定义文档的样式信息。&lt;table&gt;： 定义表格。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>语义化</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入 URL 到页面展示发生了什么事情]]></title>
    <url>%2F2017%2F%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85.html</url>
    <content type="text"><![CDATA[这是一道经典的前端面试题，在学习的过程中，我想如果通过自己的语言来描述出来印象会更加深刻。 什么是URL URL(Uniform / Universal Resource Locator)统一资源定位符，如同在网络上的门牌，是因特网上标准的资源的地址。URL的标准格式如下：协议类型://服务器地址（必要时需加上端口号）/路径/文件名 例如：http://www.jianshu.com/users/78757d5285cd/timeline协议：http网络地址：www.jianshu.com资源路径：users/78757d5285cd/timeline 流程浏览器中输入URL并回车浏览器查找域名的IP地址1. 浏览器缓存 – 浏览器会缓存DNS记录一段时间 2. 系统缓存 - 从 Hosts 文件查找是否有该域名和对应 IP。 3. 路由器缓存 – 一般路由器也会缓存域名信息。 4. ISP DNS 缓存（互联网服务提供商的DNS缓存） – 比如到电信的 DNS 上查找缓存。 5. 如果都没有找到，则向根域名服务器查找域名对应 IP，根域名服务器把请求转发到下一级，直到找到 IP 浏览器发送一个HTTP请求到web服务器服务器处理 常见的 web服务器有 Apache、Nginx、IIS、Lighttpd web服务器接收用户的Request 交给网站代码，或者接受请求反向代理到其他 web服务器网站处理URL中的文件地址部分经过服务器上的路由程序重定向到对应的控制器(controller)对象,控制器对象根据URL中指定的操作执行相关的逻辑并调用目标数据的模型(Model)对象,模型对象与数据库交互完成目标操作后,控制器将模型中反馈的数据填充到视图中。视图部分(通常是HTML页面)作为HTTP响应发送到浏览器端。浏览器处理HTML字符串被浏览器接受后被一句句读取解析解析到link 标签后重新发送请求获取css解析到 script标签后发送请求获取 js，并执行代码解析到img 标签后发送请求获取图片资源绘制网页将渲染好的页面图像显示出来，并开始响应用户的操作。 以上只是一个简单的流程，过程中还会涉及到很多问题。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
        <tag>URL</tag>
      </tags>
  </entry>
</search>
